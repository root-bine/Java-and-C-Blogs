## 1、<span style="color:brown">编码器概述：</span>

**1.1、结构分析：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/EnCoder01.png" alt="image-20251203181621807" style="zoom:45%;" />

编码器有<u>**四根线**</u>：`A\B`是**编码输出**，`S`是**按钮状态（左右旋转、按压）**，`C`是**公共端（接GND）**。

**1.2、A\B信号说明：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/EnCoder02.png" alt="image-20251203183230120" style="zoom: 50%;" />

从电信号波形，对比<u>`A/B`的<span style="color:red">上升沿</span>的快慢</u>：

| `CW`方向：`A` > `B` | `CCW`方向：`A` <  `B` |
| :-----------------: | :-------------------: |



## 2、<span style="color:brown">EXTI控制：</span>

**2.1、原理图：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/EnCoder03.png" alt="image-20251203184243502" style="zoom: 50%;" />

参数配置：

1. 配置`A1 GPIO`为`EXIT输入`，设置为<span style="color:green"><u>**上升沿触发 / 双边沿触发**</u></span>，并在**NVIC开启中断**；
2. 配置`B1 GPIO`为`GPIO Input`；
3. 两个`GPIO`根据原理图，设置为**上拉电阻**；
4. **开启USART**，设置为**异步模式**，用于串口打印；

**2.2、上升沿判断：**

根据**A\B信号波形**对比，可以在**A上升沿**时，判断**B的电平信号**，从而判断方向：

````c
#include <stdio.h>
#include <stdbool.h>
bool is_ccw_end = false;
bool is_cw_end = false;
int fputc(int ch, FILE *f) {
    HAL_UART_Transmit(&huart1 , (uint8_t *)&ch, 1, 0xFFFF);
    return ch;
}
while (1) {
	if(is_ccw_end == true){
        is_ccw_end = false;
      	printf("CCW\n");
    }
    if(is_cw_end == true){
      	is_cw_end = false;
      	printf("CW\n");
    }
}
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
	if(GPIO_Pin == A1_Pin) {
		if(HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) == GPIO_PIN_RESET) {
			is_cw_end = true;
		} else {
			is_ccw_end = true;
		}
	}
}
````

**2.3、双边沿判断：**

在**触发`A`的上升、下降边沿中断**时，捕获`B`和`A`项的电平，再根据**两次捕获B和A项的值**就可以知道**旋转的方向**。

````c
#include <stdio.h>
#include <stdbool.h>
bool is_ccw_start = false;
bool is_ccw_end = false;
bool is_cw_start = false;
bool is_cw_end = false;
int fputc(int ch, FILE *f) {
    HAL_UART_Transmit(&huart1 , (uint8_t *)&ch, 1, 0xFFFF);
    return ch;
}
while (1) {
    if(is_ccw_end == true){
        is_ccw_end = false;
        printf("正转\n");
    }
    if(is_cw_end == true){
        is_cw_end = false;
        printf("反转\n");
    }
  }
//设置ccw方向标志位, 起始或结束标志
void set_ccw_status(){
    if(is_ccw_start == true){
        is_ccw_end = true;   //第二次触发为真正信号
    } else {
        is_ccw_start = true; //首次触发为开始
    }
}
//设置cw方向标志位, 起始或结束标志
void set_cw_status(){
    if(is_cw_start == true){
        is_cw_end = true;
    } else {
        is_cw_start = true;
    } 
}
//需要同时满足上升沿和下降沿对应的信号才算触发
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin){        
	if(GPIO_Pin == A1_Pin) {  //判断中断来自哪一条中断线
        //下降沿中断 
		if(HAL_GPIO_ReadPin(A1_GPIO_Port, A1_Pin) == 0) { 
			if(HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) == 0) {  //CCW方向
				set_ccw_status();
				is_cw_start = false; //如果是CCW方向的触发，可以把CW方向的标志清空
          	}else { //CW方向
				set_cw_status();
				is_ccw_start = false; //如果是CW方向的触发，可以把CCW方向的标志清空
          }
        } else { // 上升沿中断
         	if(HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) == 0) { //CW方向
				set_cw_status();
				is_ccw_start = false;
         	}else { //CCW方向
             	set_ccw_status();
             	is_cw_start = false;
         	}
       }
    }
}
````

