# Iterator<E>

## 1、<span style="color:brown">Iterator接口的概述：</span>

**1.1、Iterator接口的用途：**

1. 在程序设计过程中，需要对集合中的元素进行遍历；
2. 因此，`java.util.Iterator`接口便是这一作用；

**1.2、Iterator接口与Collection接口的区别：**

```apl
1.Collection接口与Map接口主要用于存储元素;
2.Iterator接口主要用于 “迭代访问(遍历)” Collection集合中的元素;
3.Iterator对象，也被称为“迭代器”;
```

## 2、<span style="color:brown">迭代器概述：</span>

**2.1、含义：**

​	**<u>*集合元素的通用获取方式*</u>**

**2.2、原理：**

在取出元素之前，判断该元素是否在集合中存在。如果存在，则取出，然后继续判断，否则一直到该集合元素全部被取出为止；

**2.3、获取迭代器的方法：**

```java
public Iterator iterator()
    1.获取集合的迭代器对象，遍历集合中的元素;
	2.指针(索引)指针指向集合索引的-1位置;
```

**2.4、迭代器使用步骤：**

1. 使用集合中的方法`iterator`，获取迭代器的实现类对象，使用Iterator接口接收（多态）；
2. 使用Iterator接口的`hasNext方法`，判断是否还有下一个元素；
3. 使用Iterator接口的`next方法`，取出集合中的下一个元素；

## 3、<span style="color:brown">Iterator接口的常用方法：</span>

```java
public E next()
    返回迭代的下一个元素;
```

```java
public boolean hasNext()
    如果还有元素可以迭代，返回true;
```

## 4、<span style="color:brown">迭代器代码实现：</span>

```java
public class Demo02Iterator {
    public static void main(String[] args) {
        //创建一个集合对象
        Collection<String> coll = new ArrayList<>();
        //添加集合元素
        coll.add("詹姆斯");
        coll.add("本杰明");
        coll.add("杰瑞");
        coll.add("汤姆");
        coll.add("哈迪斯");
        //获取集合的迭代器
        Iterator<String> it = coll.iterator();
        /*for (int i = 0; i < coll.size(); i++) {
            //判断集合中是否存在下一个元素
            if(it.hasNext()){
                //存在下一个元素，则取出
                String next = it.next();
                System.out.println("第1种循环优化:"+next);
            }
        }*/
        while(it.hasNext()){
            String next = it.next();
            System.out.println("第2种循环优化:"+next);
        }
    }
}
```

## 5、<span style="color:brown">快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别?</span>

> Iterator 的安全失败是基于对底层集合做拷贝，即：它不受源集合上修改的影响

|               参照对象               |   类别    |
| :----------------------------------: | :-------: |
|    java.util 包下面的所有的集合类    | fail-fast |
| java.util.concurrent包下面的所有的类 | fail-safe |

**fail-fast的迭代器**会抛出 ConcurrentModificationException 异常，而**fail-safe的迭代器**永远不会抛出这样的异常

