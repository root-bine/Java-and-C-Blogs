## 1、<span style="color:brown">三次握手：</span>Three-way Handshake[建立连接]

**1.1、概述：**

```scss
建立一个TCP连接时, 需要客户端和服务器总共发送3个包

初始状态：
	客户端处于 Closed 状态;
	服务端处于 Listen 状态;
```

**1.2、作用：**

> ***实质：***<span style="color:red">连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息</span>！！！

1. 确认双方的**接收能力和发送能力是否正常**
2. **指定自己的初始化序列号**为后面的<u>可靠性传送</u>做准备

**1.3、三次握手过程中可以携带数据吗？**

​	<span style="color:red">第`3`次握手的时候，是可以携带数据的，第`1`次、第`2`次握手不可以携带数据</span>。

​	假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。攻击者根本就不理会服务器的接收、发送能力是否正常，只需要疯狂着重复发 SYN 报文，就可以<u>让服务器花费很多时间、内存空间来接收这些报文</u>。

​	对于第三次握手，此时客户端已经处于 `ESTABLISHED(已确认连接)` 状态。对于客户端来说，已经建立起连接，并且已经知道服务器的接收、发送能力是正常的。

**1.4、什么是半连接队列？**

1. 服务器**第一次收到客户端的 SYN报文** 之后，就会**处于 SYN_RCVD 状态**；
2. 但此时双方还**没有完全建立其连接**，服务器会*把此种状态下请求连接放在一个队列里*；

***补充：***<span style="color:Orange">**已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象！！！**</span>

**1.5、SYN攻击是什么？**

​	Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认。由于源地址不存在，因此Server需要不断重发直至超时。
​	这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪！！

***补充：***<span style="color:blue">**服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击**</span>



## 2、<span style="color:brown">四次挥手：</span>Four-way handshake[终止连接]

**2.1、概述：**

```scss
TCP 连接的拆除需要发送四个包   ----->  四次挥手

TCP的半关闭:     ------>   建立一个连接需要三次握手，而终止一个连接需要四次挥手
	TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力;

初始状态:
	刚开始双方都处于ESTABLISHED(已确认连接)状态
```

**2.2、挥手为什么需要四次？**

1. 当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。
   - 其中**ACK报文是用来应答的，SYN报文是用来同步的**。
2. 当关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文；
   - 告诉客户端，“你发的FIN报文我收到了”。
3. 只有等到我服务端所有的报文都发送完了，我才能发送FIN报文。

**2.3、TCP的双全工特性：**

- 在四次挥手中，由于TCP连接是全双工的，因此每个方向都必须单独进行关闭；
- 当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接；
- 收到一个FIN只意味着这一方向上没有数据流动，但仍能发送数据；



## 3、<span style="color:brown">三次握手和四次挥手的过程：</span>

**3.1、三次挥手：**

1. 第一次握手：客户端向服务器发送一个`SYN（同步）包`，其中包含一个随机生成的`初始序列号（ISN）`；
2. 第二次握手：服务器收到客户端的`SYN包`后，会发送一个`SYN+ACK（同步+确认）包`作为响应：
   - 该包中确认了客户端的`SYN`，并且也包含一个随机生成的`ISN`
3. 第三次握手：客户端收到服务器的`SYN+ACK包`后，会发送一个`ACK（确认）包`给服务器，确认收到了服务器的响应。同时，客户端也会将<u>服务器的`ISN`加1作为下一次通信的初始序列号</u>；

**3.2、四次挥手：**

1. 第一次分手：当客户端决定关闭连接时，发送一个`FIN（结束）包`给服务器；
2. 第二次分手：服务器收到客户端的`FIN包`后，会发送一个`ACK包`作为响应，确认收到了客户端的关闭请求；
3. 第三次分手：服务器发送一个`FIN包`给客户端，表示服务器也准备关闭连接；
4. 第四次分手：客户端收到服务器的`FIN包`后，发送一个`ACK包`作为响应，确认收到了服务器的关闭请求；



## 4、<span style="color:brown">浏览器输入一个地址，到页面展示中间经历了哪些过程？</span>

1. 浏览器输入URL：
   - 先解析url地址是否合法
2. 浏览器检查是否有缓存【浏览器缓存-系统缓存-路由器缓存】：
   - 如果有，直接显示
   - 如果没有，跳到第三步
3. 在发送http请求前，需要域名解析-------------**DNS解析**
   - 解析获取对应过的IP地址
4. **浏览器向服务器发起TCP链接**：
   - 建立TCP连接
5. 握手成功后，浏览器向服务器发送HTTP请求：
   - 请求数据包
6. 服务器收到处理的请求，将**数据返回至浏览器**
7. 浏览器收到HTTP响应
8. 浏览器解析响应：
   - 如果响应可以缓存，则存入缓存
9. 浏览器发送请求获取嵌入在HTML中的资源【html，css，JavaScript，图片，音乐等】：
   - *对于未知类型，会弹出对话框*
10. 浏览器发送异步请求
11. 页面全部渲染结束