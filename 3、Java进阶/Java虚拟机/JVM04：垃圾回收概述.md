## 1、<span style="color:brown">判断对象回收：</span>

**1.1、引用计数法：**

> Python的虚拟机就采用的引用计数法进行垃圾回收

如果一个对象被其他变量引用<u>一次/两次/n次</u>，就<u>count+1/count+2/count+n</u>，而当某个对象不在引用这个对象时，就count-1。直到这个对象的计数变为0时，就将这个对象进行回收。

---

对于循环引用：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt="image-20221130183022913" style="zoom:67%;" />

此时A引用B，count_B = count_B + 1，然后B又引用A，count_A = count_A + 1，而没有其他变量引用A、B。

但A、B依旧无法进行垃圾回收，因为此时A、B的计数都为1.

**1.2、可达性分析算法：**

> Java的虚拟机采用的
>
> GC Roots的特点：当前活着的对象

Java虚拟机中的垃圾回收器采用*可达性分析*来探索所有存活的对象。

扫描堆中的对象，看是否能够<u>*沿着一系列被称为GC Root的对象为起点的引用链*，向下查找</u>该对象：

- 存在，该对象保留；
- 不存在，该对象回收；

---

在Java语言中，可以作为GC Root的对象包含下面几种：

|                   类型                    |                             范例                             |
| :---------------------------------------: | :----------------------------------------------------------: |
|  虚拟机栈中，<u>局部变量表引用的对象</u>  |        各个线程被调用的方法中使用到的参数、局部变量等        |
|   方法区中，<u>类静态属性引用的对象</u>   |                   Java类的引用类型静态变量                   |
|      方法区中，<u>常量引用的对象</u>      |            字符串常量池（string Table） 里的引用             |
| 本地方法栈中，<u>Native方法引用的对象</u> |                              \                               |
|    所有被同步锁synchronized持有的对象     |                              \                               |
|           Java虚拟机内部的引用            | 基本数据类型对应的Class对象、一些常驻的异常对象（如：NullPointerException、OutOfMemoryError）、系统类加载器 |

**1.3、引用：**

|                引用名称                |                             定义                             |                             分析                             |
| :------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|                 强引用                 |                   在程序代码之中普遍存在的                   | 类似“Object obj = new Object0”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象 |
|                 软引用                 |          用来描述一些<u>还有用但并非必需</u>的对象           | 对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。***在JDK1.2之后，提供了SofReference类来实现软引用***。 |
|                 弱引用                 |   用来描述<u>非必需对象，但它的强度比软引用更弱一些</u>。    | *被弱引用关联的对象只能生存到下一次垃圾收集发生之前*。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。<u>***在JDK12之后，提供了WeakRefenence类来实现弱引用***</u>。 |
| 虚引用，也称为*幽灵引用*或者*幻影引用* | 它是最弱的一种引用关系。一个对象是否有虚引用的存在,完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。 | 为一个对象设置虚引用关联的唯一目的就是<u>*能在这个对象被收集器回收时收到一个系统通知*</u>。<u>**在JDK12之后,提供了PhantomReference类来实现虚引用**</u>。 |

**1.4、垃圾回收对象的过程：**

在可达性分析算法中不可达的对象，不一定会被垃圾回收。因此，一个对象的死亡经历两个阶段：

- 对象在进行可达性分析后，发现没有与GC Roots相连接的引用链，会被第一次标记且进行一次筛选；
  - 筛选条件：此对象是否有必要执行finalize()方法
  - JVM默认不执行情况：对象没有覆盖finalize()方法、finalize()方法已经被虚拟机调用过
- 如果对象被判定为执行finalize()方法，就会被放在F-Queue的队列中，并稍后由一个JVM自动创建、低优先级的Finalize线程执行；
  - 此时GC会对F-Queue的队列中对象，进行第二次小规模标记
  - 如果希望对象不被回收，***只需要重新与引用链上的任何一个对象建立连接***即可

---

执行finalize()方法，是指：<u>***JVM触发着方法***，并不需要等待这个方法运行结束</u>。原因在于：如果对象在finalize()方法中<u>执行缓慢/发生了死循环</u>，这就导致在**F-Queue队列中的其他对象永久等待**，以至于导致整个垃圾回收系统崩溃！！！



## 2、<span style="color:brown">垃圾回收算法：</span>



## 3、<span style="color:brown">分代垃圾回收：</span>