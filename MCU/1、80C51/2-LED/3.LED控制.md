## 1、<span style="color:brown">bit、sbit、sfr：</span>

> `bit、sbit`都是`C51`扩展内容

**1.1、bit：**

`bit`是一种数据类型，大小是`1 bit`，数值为**`0`或`1`**：

```c
bit i = 0; // 在内存中划一块空间给i, 并存储数值0
bit i = 1; // 在内存中划一块空间给i, 并存储数值1
```

**1.2、sfr：**

`Special Function Register`，简称**sfr**，用于定义一个**字节寄存器**（8 位整体操作）：

```c
sfr P4 = 0xE8; // 定义 P4 口寄存器, 物理地址 0xE8
```

**1.3、sbit：**

`sbit`是为**已经分配内存空间的变量**重新<u>取一个别名</u>，一般用来<u>定义特殊功能寄存器</u>的**位变量**，例如

```Java
sfr P1 = 0x90;
sbit Flag = P1^1;
Flag = 0; // 输出低电平
Flag = 1; // 输出低电平
```



## 2、<span style="color:brown">时钟周期、机器周期、指令周期：</span>

**2.1、时钟周期：**

> 单片机的主时钟频率是：外部晶振

假设：`12M`的晶振，时钟周期为`1/12 us`，是计算机中**最基本的、最小的时间单位**。

|   术语   |                       说明                       |
| :------: | :----------------------------------------------: |
|   主频   | **芯片主时钟的频率**，通常以`MHz`或者`GHz`为单位 |
| 时钟周期 |                  晶振频率的倒数                  |

**2.2、机器周期：**
一般情况下，一个机器周期由若干个时钟周期组成。

<u>取指令、存储器读、存储器写</u>等每一个基本操作，**<u>完成所需要的时间</u>称为**机器周期。

**2.3、指令周期：**

> Control Unit，简称CU，即：控制器
>
> Arithmetic Logic Unit，简称ALU，即：算术逻辑单元
>
> Instruction register，简称IR，即：指令寄存器
>
> Memory，即：内存

`CPU`从**存储器**中**取出并执行一条指令所需的全部时间**，称之为**指令周期**。

| 阶段                                   | 主要内容                                                     |
| :------------------------------------- | :----------------------------------------------------------- |
| **取指令 **<br/>`Instruction Fetch`    | 1. **PC Register**给出指令地址<br>2. 从**Memory**取出指令<br>3. 指令送入 **IR**<br>4. **PC Register**更新到下一条指令地址 |
| **指令译码**<br/> `Instruction Decode` | 1. `Control Unit`读取 **IR 内的指令**<br/>2. 判断**指令类型**（算术/逻辑/传输/跳转等）<br/>3. 解析**需要的操作数**、**目标寄存器 / 内存地址**<br/>4. 生成**控制信号** |
| **执行**<br/>`Execute`                 | 1. ALU 根据**控制信号**执行操作（算术/逻辑）<br/>2. 完成数据传送（寄存器 ↔ 内存 ↔ I/O）<br/>3. 若为分支/跳转，**PC Register**更新为<u>新地址</u><br/>4. 结果写回`Register`或`Memory` |



## 2、<span style="color:brown">软件空转延时：</span>

> 软件空转延时仅作为了解，核心是**定时器**和**RTOS** 

**2.1、STC-ISP工具生成：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/LED08.png" alt="image-20250909182104404" style="zoom: 50%;" />

`#include "intrins.h"`，是`Keil`给`80C51`单片机编程时，提供的**“内联<u>汇编/固有</u>函数（intrinsic functions）”声明文件**：

| 函数           | 功能                      |
| -------------- | ------------------------- |
| `_nop_()`      | 空操作，执行 1 个机器周期 |
| `_cror_(x, n)` | 循环右移                  |
| `_crol_(x, n)` | 循环左移                  |
| `_push_(x)`    | 将变量压栈                |
| `_pop_(x)`     | 将变量出栈                |
| `_mul_(a, b)`  | 8 位 × 8 位乘法           |
| `_div_(a, b)`  | 8 位 ÷ 8 位除法           |

**2.2、12 Mhz晶振延时：**

> `j = 124`，是根据**CPU 主频**和编译器生成的**机器码指令周期数**算出来的

```c
//带参延时函数
void delay_ms(unsigned int xms) {  //@12MHz
    unsigned int i, j;
    for(i=xms;i>0;i--)
    {
        for(j=124;j>0;j--) {}
    }
}
```



## 3、<span style="color:brown">灯效控制：</span>

**3.1、单LED闪烁：**

整个IO端口赋值：

```c
#include "reg52.h"
void delay_ms(unsigned int xms);
void main(){
	P2 = 0x7F; // 0111 1111, LED1亮
	delay_ms(500);
	P2 = 0xFF; // 1111 1111, LED1熄灭
	delay_ms(500);
}
```

使用`sbit`操作寄存器的位变量：

```c
#include <reg52.h>
void delay_ms(unsigned int xms);
sbit LED1 = P2^7; // LED 1
int main() {
	LED1 = 0; // LED1亮
	delay_ms(500);
	LED1 = 1; // LED1熄灭
	delay_ms(500);
}
```

**3.3、LED流水灯：**

根据**GPIO**和**LED原理图**，可以针对<u>LED1、LED2、LED3</u>所在的`Register-Bit`进行操作

```c
sbit LED1 = P2^7; // LED 1
sbit LED2 = P2^6; // LED 2
sbit LED3 = P2^5; // LED 3
while(1) {
	LED1 = 0;
	LED2 = 1;
	LED3 = 1;
	delay_ms(500);
	LED1 = 1;
	LED2 = 0;
	LED3 = 1;
	delay_ms(500);
	LED1 = 1;
	LED2 = 1;
	LED3 = 0;
	delay_ms(500);
}
```

根据`datasheet`中，**`P2`端口**的复位值是：`1111 1111B`，`LED1 = 0;LED2 = 1;LED3 = 1;`可<span style="color:red">优化</span>为：

```c
P2 = 0xDF; //1101 1111, 操作P2.5, LED3
P2 = 0xBF; //1011 1111, 操作P2.6, LED2
P2 = 0x7F; //0111 1111, 操作P2.7, LED1
```

该步骤也可以简化为一个函数：

```c
// 0xFF = 1111 1111
// 1    = 0000 0001
void open_led(unsigned int num){
    P2 = 0xFF & ~(1 << num);
}
```

`~(1 << num)`表示左移`num`位，并取反，在与0xFF按位与，效果等同上一个方案！

