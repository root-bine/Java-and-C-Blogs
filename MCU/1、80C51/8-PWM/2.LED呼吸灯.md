## 1、<span style="color:brown">PWM控制呼吸灯：</span>

**1.1、软件空转延时：**

```c
#include <reg52.h>
sbit led = P2^7;
int time = 0;
void Delay10usofTime(unsigned int time) {	// 根据time决定执行多少次10us延时
	while(time--) {
		unsigned char data i;
		i = 2;
		while (--i);
	}
}
void main() {
	while(1) {
		for(time = 0; time < 300; time ++){ //从暗逐渐变亮的过程
			led = 0;
      		Delay10usofTime(time);
      		led = 1;
      		Delay10usofTime(300 - time);
    	}
    	for(time = 0; time < 300; time ++){ //从亮逐渐变暗的过程
      		led = 1;
      		Delay10usofTime(time);
      		led = 0;
      		Delay10usofTime(300 - time);
    	}
  	}
}
```

`Delay10usofTime(time) + Delay10usofTime(300 - time)`组成一个完整的**PWM周期**。

而`for(time = 0; time < 300; time ++)`是**动态调整Duty的占比**。

**1.2、定时器中断：**

````c
#include <reg52.h>
#define TIME_OUT (65536 - 9)
sbit led = P2^7;
bit dir = 1;                    // 占空比变化方向：1=递增（渐亮），0=递减（渐暗）
unsigned int pwm_period = 300;  // PWM周期
unsigned int count = 0, duty = 0;
void Timer0Init(); 						// 调试时, 需补充完整
void Delay10usofTime(unsigned int time) // 调试时, 需补充完整
void Timer0_ISR() interrupt 1 {
    TL0 = TIME_OUT;
    TH0 = TIME_OUT >> 8;
    count++;
    if(count >= pwm_period) {
		count = 0;
	}
    if (count < duty) {
        led = 1;
    } else {
        led = 0;
    }
}
void main() {
    Timer0Init();  // 初始化定时器
    while(1) {
        if (dir == 1) { // 渐亮过程: 占空比从0增加到pwm_period-1
            duty++;
            if (duty >= pwm_period) {
                dir = 0;  // 达到最亮，切换为渐暗
            }
        } else { // 渐暗过程: 占空比从pwm_period-1减少到0
            duty--;
            if (duty == 0) {
                dir = 1;  // 达到最暗，切换为渐亮
            }
        }
		// 控制 渐亮过程&渐暗过程 的交替速度
        Delay10usofTime(10);
    }
}
````



## 2、<span style="color:brown">PWM + Timer：</span>流水呼吸灯

**2.1、配置必要参数：**

```c
#include <reg52.h>
#define TIME_OUT (65536 - 9)
unsigned int dir = 1;                    // 占空比变化方向：1=递增（渐亮），0=递减（渐暗）
unsigned int pwm_period = 300;  // PWM周期
unsigned int count = 0, duty = 0;
unsigned char led_index = 5; 
```

**2.2、配置Timer0与delay：**

```c
void Timer0Init() {
    TMOD &= 0xF0;
    TMOD |= 0x01;
    TL0 = TIME_OUT;
    TH0 = TIME_OUT >> 8;
    ET0 = 1;
    EA = 1;
    TR0 = 1;
}
void Delay10usofTime(unsigned int time) {	// 根据time决定执行多少次10us延时
	while(time--) {
		unsigned char data i;
		i = 2;
		while (--i);
	}
}
```

**2.3、控制LED亮灭：**

````c
void set_led(unsigned char index) {
    P2 &= ~(1 << index);     // 点亮（低电平）
}
````

**2.3、中断服务函数：**

```c
void Timer0_ISR() interrupt 1 {
    TL0 = TIME_OUT;
    TH0 = TIME_OUT >> 8;
    count++;
    if(count >= pwm_period) {
		count = 0;
	}
    P2 = 0xFF;           // 每次将LED全部熄灭
    if (count < duty) {  // 控制LED_ON, 不需要LED_OFF操作, P2 = 0xFF已完成
        set_led(led_index);
    }
}
```

通过`count`限定一个完整的**PWM周期**，并与`duty`进行比较，设定**<span style="color:red">有效电平</span>占比**。

这里<span style="color:red">**不对无效电平**进行逻辑处理，而是采用`P2 = 0xFF`</span>，原因是：

1. 中断会重写整个`GPIO`，保证**没有LED余光残留**影响**亮度**；
2. 对无效电平进行逻辑处理，会出现**LED呼吸卡顿**；

**2.4、main函数：**

```c
void main() {
    Timer0Init();  // 初始化定时器
    while(1) {
        if (dir == 1) { // 渐亮过程: 占空比从0增加到pwm_period-1
            duty++;
            if (duty >= pwm_period) {
                dir = 0;  // 达到最亮，切换为渐暗
            }
        } else { // 渐暗过程: 占空比从pwm_period-1减少到0
            duty--;
            if (duty == 0) {
                dir = 1;  // 达到最暗，切换为渐亮
                led_index++;
                if(led_index > 7) {
                    led_index = 5;
                }
            }
        }
		// 控制 渐亮过程&渐暗过程 的交替速度
        Delay10usofTime(10);
    }
}
```

`LED`会经历两个过程：

| 1、LED从暗     ->    亮 | 2、LED从亮     ->     暗 |
| :---------------------: | :----------------------: |

当LED再次完全变暗时，即`duty == 0`：

- 更改LED亮暗方向，即`dir = 1`；
- 更新LED编号：`led_num`;
