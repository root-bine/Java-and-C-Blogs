# 事务

## 1、<span style="color:brown">基本介绍：</span>

**1.1、事务的概念：**

<span style="color:green">**一个包含多个步骤的业务操作，如果被事务管理，那么这些操作要么同时成功，要么同时失败**</span>！！

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86.png" style="zoom:67%;" />

**1.2、事务管理的基本步骤：**

1. 开启事务：`start  transaction`
2. 回滚：`rollback`
3. 提交事务：`commit`

**1.3、范例：**

1. 有异常情况：结果显示zhangsan的金额-500，lisi的金额不变

   ```sql
   -- 【张三给李四转帐500元】
   -- 0.开启事务
   start transaction;
   -- 1.张三账户金额 -500
   update account set balance = balance - 500 where name = 'zhangsan';
   -- 2.李四账户金额 +500
   '出错了....'
   update account set balance = balance + 500 where name = 'lisi';
   -- 如果没有异常，就直接提交事务
   commit;
   -- 出现异常，回滚
   rollback;
   ```

2. 无异常情况：结果显示zhangsan 金额-500，lisi金额+500

   ```sql
   -- 【张三给李四转帐500元】
   -- 0.开启事务
   start transaction;
   -- 1.张三账户金额 -500
   update account set balance = balance - 500 where name = 'zhangsan';
   -- 2.李四账户金额 +500
   update account set balance = balance + 500 where name = 'lisi';
   -- 如果没有异常，就直接提交事务
   commit;
   -- 出现异常，回滚
   rollback;
   ```

**1.4、事务提交的两种方式：**

1. 自动提交：

   - MySQL数据库默认是自动提交；
   - 一条DML语句也是自动体提交事务；

2. 手动提交：

   - Oracle数据库默认是手动提交；

   - 需要开启事务，再提交；

**1.5、修改事务默认提交方式：**

> 1 代表自动提交，0 代表手动提交

1. 查看事务默认提交方式：`select  @@autocommit;`   

2. 修改默认提交方式：`set  @@autocommit = 0;`



## 2、<span style="color:brown">事务详解：</span>

**2.1、事务的四大特征：**

1. `原子性`：一个事务内的所有操作是一个整体，要么全部成功，要么全部失败；
2. `持久性`：事务一旦提交或者回滚，数据库会持久化的保存数据；
3. `隔离性`：多个事务之间，相互独立；
4. `一致性`：事务操作前后，数据的总量不变；

**2.2、隔离级别概述：**

1. 多个事务之间是：隔离的，相互独立的；
2. 如果<span style="color:orange">**多个事务操作同一批数据**</span>，则会引发一些问题，需要<span style="color:green">**设置不同的隔离级别**</span>；



## 3、<span style="color:brown">隔离级别：</span>

**3.1、存在的问题：**

1. 脏读：一个事务读取另外一个事务**还没有提交的数据**；

   ```scss
   张三的工资为5000, 事务A中把他的工资改为8000, 但事务A尚未提交。
   与此同时:
   事务B正在读取张三的工资, 读取到张三的工资为8000
   随后: 
   事务A发生异常, 而回滚了事务, 因此: 张三的工资又回滚为5000
   最后:
   事务B读取到的张三工资为8000的数据, 即为脏数据,
   ['事务B做了一次脏读']
   ```

2. 不可重复读：在同一个事务中，两次读取到的数据不同；

   ```scss
   在事务A中, 读取到张三的工资为5000, 操作没有完成, 且事务还没提交
   与此同时:
   事务B把张三的工资改为8000, 并提交了事务
   随后:
   在事务A中, 再次读取张三的工资, 此时工资变为8000
   [在一个事务中'前后两次读取的结果并不致, 导致了不可重复读']
   ```

3. 幻读（虚读）：同样一笔查询在整个事务过程中<u>*多次执行后*</u>，**查询所得的结果集**是不一样的；

   ```scss
   目前工资为5000的员工有10人, 事务A读取所有工资为5000的人数为10人
   此时: 
   事务B插入一条工资也为5000的记录
   这时, 事务A再次读取工资为5000的员工, 记录为11人
   ['此时产生了幻读']
   ```
   

**3.2、隔离级别与产生的问题：**

> 隔离级别从小到大，安全性越来越高，但是效率越来越低
>
> 随着隔离级别的提升，产生的问题到serializable级别则基本可以全部解决

|                事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| :-----------------------------------------: | :--: | :--------: | :--: |
|        `read  uncommitted`：读未提交        |  √   |     √      |  √   |
| `read  committed`：读已提交【Oracle数据库】 |      |     √      |  √   |
| `repeatable  read`：可重复读【Mysql数据库】 |      |            |  √   |
|           `serializable`：串行化            |      |            |      |

**3.3、数据库对隔离级别的操作：**

1. 查询隔离级别：

   > MySQL8版本以前

   `select @@global.tx_isolation,@@tx_isolation;`

   > MySQL8版本以后

   `select @@global.transaction_isolation,@@transaction_isolation;`

2. 设置隔离级别：此处设置成功后，需重启数据库

   `set session transaction isolation level 事务隔离级别;`