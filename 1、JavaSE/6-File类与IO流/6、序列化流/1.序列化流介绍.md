## <!--序列化与反序列化都是针对于对象-->

## 1、<span style="color:brown">基础内容：</span>

**1.1、概述：**

1. Java提供了一种<u>***对象序列化的机制***</u>。使用一个字节序列表示一个对象，该序列包含：对象的名称、对象的类型、对象存储的属性等信息；【字节序列写入文件】
2. 该字节序列也可以从文件中读取出来，重构对象，对其进行<u>***反序列化***</u>。【字节序列读取文件】

**1.2、图解：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" style="zoom:80%;" />



## 2、<span style="color:brown">详解：</span>

**2.1、对象的序列化：**

1. 把对象以流的形式，写入到文件中保存；`写对象`
2. ObjectOutputStream：对象的序列化流



**2.2、对象的反序列化：**

1. 把文件中保存的对象，以流的方式读取出来；`读对象`
2. ObjectInputStream：对象的反序列化流



**2.3、异常：**NotSerializableException

1. 在序列化与反序列化的时候，会抛出`NotSerializableException【没有序列化异常】`；
2. 类必须通过`实现java.io.Serializable接口`，来开启序列化与反序列化；



## 3、<span style="color:brown">transient：</span>

**3.1、<u>static与transient</u>的区别：**

1. 静态优先于非静态；
2. 静态优先于对象进入内存；
3. 被static修饰的成员变量均不能序列化；

**3.2、transient关键字小结：**

1. 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问；
2. transient关键字只能修饰变量，而不能修饰方法和类；



## 4、<span style="color:brown">反序列化抛出的异常：</span>InvalidClassException

**4.1、概述：**

1. 当JVM反序列化时，能找到class文件。
2. 如果class文件在序列化之后，发生了改变，那么反序列化就会失败；
3. 并且在失败的同时，也会抛出一个InvalidClassException异常；

**4.2、解决方案：**

在实现Serializable接口的类中，Serializable接口提供了一个serialVersionUID的常量。

- <u>*不考虑和老数据兼容*</u>

  ```java
  private static final long serialVersionUID = 数值;
  	该版本号主要用于验证"序列化的对象与对应类"是否匹配;
  ```

- *与老数据兼容：*

  ```java
  private static final long serialVersionUID = 1631280650588763177L;
  ```

**4.3、演示：**

```java
public class TransientTest {
    public static void main(String[] args) {
        User user = new User();
        user.setUsername("Alexia");
        user.setPasswd("123456");
        System.out.println("read before Serializable: ");	//read before Serializable: 
        System.out.println("username: " + user.getUsername());	//username: Alexia
        System.err.println("password: " + user.getPasswd());	//password: 123456
        
        try {
            ObjectOutputStream os = new ObjectOutputStream(
                    new FileOutputStream("C:/user.txt"));
            os.writeObject(user); // 将User对象写进文件
            os.flush();
            os.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            ObjectInputStream is = new ObjectInputStream(new FileInputStream(
                    "C:/user.txt"));
            user = (User) is.readObject(); // 从流中读取User的数据
            is.close();
            
            System.out.println("read after Serializable: ");	//read after Serializable: 
            System.out.println("username: " + user.getUsername());	//username: Alexia
            System.err.println("password: " + user.getPasswd());	//password: null
            
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
 
class User implements Serializable {
    private static final long serialVersionUID = 8294180014912103005L;  
    
    private String username;
    private transient String passwd;
 	// Getter and Setter
}
```

