# 注解

## 1、<span style="color:brown">概念</span>:

**1.1、注释：**

​	用文字描述程序各部分功能或者作用，主要是用于程序员更好理解程序的组成和功能。

**1.2、<span style="color:red">注解</span>：**

​	主要是说明程序的，主要是用于计算机解读。

​	1、编写文档：

​			通过在编译器中加上相对应的注释和注解，然后再代码文件出执行命令行，输入：javadoc  Java代码文件，然后就会生产相对应的     			许多文件。

​	2、代码分析：使用反射技术

​	3、编译检查：

​			通过代码的标识的注释让编辑器实现基本的编译检查；

## 2、<span style="color:brown">JDK中预定义(内置)的注解：</span>

**2.1、常见注解：**

@Override：

- 检测<span style="color:blue">被该注解标注的方法是否是继承父类</span>的；

@Deprecated:

- 该注解标注的内容，表示已过时；

@SuppressWarnings：

- 压制警报；

- <span style="color:red">使用</span>:

  - 一般需要传参数：all；

    ```java
    @SuppressWarnings("all")
    ```


**2.2、使用注解的作用：**

```
上述几种标注主要是用于给使用者区别方法的来源、是否还存在实用性、消除一些无关的代码提示等！！！！
```

## 3、<span style="color:brown">自定义注解：</span>

**3.1、格式：**

```java
public @interface 注解名称｛
    	属性列表；
｝
```

**3.2、实现范例：**

​	一旦通过上述格式进行实现，那么就相当于定义了一个新的注解。

```java
public class AnnoDemo01 {
    @Myanno
    public void show2(){
    }
}
```

```java
public @interface Myanno {
}
```

**3.3、本质：**

```java
public @interface Myanno extends java.lang.annotation.Annotation
解释：注解本质上就是接口，该接口默认继承 Annotation接口 ！！
```

**3.4、属性：**<span style="color:red">接口中定义的抽象方法</span>

1. 属性返回值类型有要求：

   - 基本数据类型
   - String
   - 枚举
   - 注解
   - 以上类型的数组

   ```java
   public @interface Myanno {
   	//String类型的抽象方法
       public abstract String name();
       //基本数据类型的抽象方法
       public abstract int age();
       //EnumeTest枚举类的抽象方法
       public abstract EnumTest enu();
       //自定义注解Myanno2的抽象方法
       public abstract Myanno2 anno();
       //String类型的数组模式的抽象方法
       String[] str();
       EnumTest[] enumTest();
   }
   ```

2. 定义了属性，在使用时必须给属性赋值:

   注意：**在使用数组类型时，参数值是用｛｝包裹，但如果内部只有一个参数值，那么｛｝可以省略**

   - 第一种赋值方法：

     ```java
     //Myanno中定义了String name()、int age()两个抽象方法
     //所以赋值时需在注解后面加上括号，并在其中执行格式：方法名 = 参数值；
     @Myanno(name = "zhangsan", age = 12)
     ```

   - 第二种赋值方法：

     ```java
     //Myanno中定义了String name() default "zhangsan"、int age()两个抽象方法
     //在name()方法后面加上关键词default，并在其后面跟上与数据类型相符合的参数值
     //因此，在注解的使用中，只需在括号内给age()方法进行赋值
     @Myanno(age = 12)
     
     //Myanno中定义了String name()、int age()、String[] str()三个方法
     @Myanno(name = "zhangsan", age = 12, str = {"abc","bca"})
     ```

   - 第三种赋值方法：(<span style="color:orange">**特殊**</span>)

     ```java
     //在Myanno中只定义了int value()一个抽象方法
     //那么，括号内的格式就变成：参数值，直接省略value
     @Myanno(12)
     
     //Myanno中定义类int value()、EnumTest enu()、Myanno2 anno()三个抽象方法
     //那么此时就需要手动输入value这属性的名称
     @Myanno(value = 12, enu = EnumTest.SPRING, anno = @Myanno2)
     
     ```

**3.5、元注解：**<span style="color:violet">**用于描述注解的注解**</span>

@Target( )：

- 描述注解的作用位置；
  - ElementType的取值：
    - TYPE：作用于类上；
    - METHOD：作用于方法上；
    - FIELD：作用于成员变量上；

@Retention( )：

- 描述注解被保留的阶段；
  - RetentionPolicy的取值：
    - SOURCE：源代码阶段
    - CLASS：类对象阶段
    - RUNTIME：运行时阶段
- 一般使用情况是，@Retention( RetentionPolicy.RUNTIME )
  - 当前被描述的注解会保留在class字节码文件中

@Documented：

- 描述注解是否被抽取到API文档中；
  - 程序会扫描改注解，如果该注解未在程序中使用，那么生成的API文档中也不会有标注好的注解显示在其中；
- 验证操作步骤：

​		创建一个文件夹----->创建两个TXT文本文档---->将Person类和Myanno3类中代码放入其中，并修改文件后缀

​		------>先在命令行中：javadoc  Myanno3.java，然后再javadoc  Person.java

@Inherited：

- 描述注解是否被子类继承；

```java
//作用于类、方法、成员变量
@Target(value = {ElementType.TYPE,ElementType.METHOD,ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Myanno3 {
}
```

```java
@Myanno3
public class Person {
    @Myanno3
    public String name;
    @Myanno3
    public int add(int a, int b){
        return a+b;
    }
}
```

## 4、<span style="color:brown">程序中的“解析”注解：</span>

**4.1、作用：**

​	获取注解定义的属性值；

**4.2、方法：**

```java
public <A extends Annotation> A getAnnotation(Class<A> annotationClass)
    1.获取注解的实现类对象;
    2.Class<A> annotationClass: 注解的class对象;
```

```java
public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) 
    1.判断注解的作用位置，是否标注有该注解;
	2.Class<? extends Annotation> annotationClass: 注解的class对象;
```



**4.3、解析注解的步骤：**

1. 获取注解定义位置的对象 (Class，Method，Filed)；
3. 调用注解中抽象方法获取配置的属性值；

**4.4、讲解范例：**

```java
/**
 * 不改变类中代码,可以创建任意方法,可以创建任意对象
 */
@pro(className = "Day01.Annotation.Show1",methodName = "show")
public class ReflectTest {
    public static void main(String[] args) throws Exception{
        //1、解析注解
        //1.1、获取该类的字节码文件对象
        Class<ReflectTest> aClass = ReflectTest.class;
        //2、获取注解的对象
        //原理：其实就是在内存中生成一个该注解接口的子类实现对象
        pro an = aClass.getAnnotation(pro.class);
        //3、调用注解对象中定义的抽象方法，获取返回值
        String className = an.className();
        String methodName = an.methodName();
        System.out.println(methodName);
        System.out.println(className);

        //4、将Show1类加载进内存
        Class cls = Class.forName(className);
        //5、创建对象
        Object obj = cls.newInstance();
        //6、获取方法对象
        Method method = cls.getMethod(methodName);
        //7、执行方法
        method.invoke(obj);
    }
}
```

```java
@Target(value = ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface pro {
    String className();
    String methodName();
}
```

```java
public class Show1 {
    public void show(){
        System.out.println("Show1...do it!!");
    }
}
```

结果：

```
show
Day01.Annotation.Show1
Show1...do it!!
```

## 5、<span style="color:brown">注解___案例:</span>

代码：

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Check {
}
```

```java
public class Calculator {
    @Check
    public void add(){
        System.out.println("1 + 0 ="+(1+0));
    }
    @Check
    public void sub(){
        System.out.println("1 - 0 ="+(1-0));
    }
    @Check
    public void mul(){
        System.out.println("1 * 0 ="+(1*0));
    }
    @Check
    public void div(){
        System.out.println("1 / 0 ="+(1/0));
    }
    //@Check
    public void show(){
        System.out.println("永无BUG!!");
    }
}
```

```java
/**
 * 简单的测试框架:
 * 当主方法执行后，会自动执行被检测的所有方法
 * 然后判断是否存在异常
 */
public class TestCheck {
    public static void main(String[] args) throws IOException {
        //1、创建计算器对象
        Calculator c = new Calculator();
        //2、获取字节码文件对象
        Class<? extends Calculator> cls = c.getClass();
        //3、获取所有方法
        Method[] methods = cls.getMethods();

        //记录出现异常的次数
        int number = 0;
        //创建一个名为bug.txt
        BufferedWriter bw = new BufferedWriter(new FileWriter("bug.txt"));
        for (Method method : methods) {
            //4、判断方法上是否有@Check(快捷键：iter)
            if(method.isAnnotationPresent(Check.class)){
                //5、存在，则执行(快捷键：Ctrl+Alt+t)
                try {
                    method.invoke(c);
                } catch (Exception e) {
                    //6、捕获异常，并记录到文件中
                    number++;
                    bw.write(method.getName()+"方法出异常了");
                    bw.newLine();
                    bw.write("异常的名称："+e.getCause().getClass().getSimpleName());
                    bw.newLine();
                    bw.write("异常的原因："+e.getCause().getMessage());
                    bw.newLine();
                    bw.write("------------------");
                    bw.newLine();
                }
            }
        }
        bw.write("本次测试一共出现"+number+"次异常！！");
        //刷新
        bw.flush();
        //关闭
        bw.close();
    }
}
```

结果：

```
1 + 0 =1
1 * 0 =0
1 - 0 =1
```

bug.txt文件内容：

```
div方法出异常了
异常的名称：ArithmeticException
异常的原因：/ by zero
------------------
本次测试一共出现1次异常！！
```

