## 1、<span style="color:brown">模式梳理：</span>

**1.1、 Mode1结构图：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Timer07.png" alt="image-20250915161019337" style="zoom:67%;" />

此模式下，`Timer0`配置为**16位定时器/计数器**，由`8 bit_TL0`和`8 bit_TH0`构成。

**1.2、其余模式：**

`Mode1、Mode2`工作模式，配置思路相同，区别在于**预装载值的配置方式**。

`Mode0`属于**`89C51`早期设计遗留**，<span style="color:red">因为范围太小，已经被`Mode1`替代</span>。

`Mode3`是将`Timer0` 拆分成<u>**两个`8 bit_Timer`**（`TL0`、`TH0`）</u>，其缺点：

1. `Timer1`功能受限：`TH0`会借用`Timer1`的控制位（`TR1、TF1`）；
2. `CPU`负担大：`8 bit_Timer`溢出频率太高，需要不断装载或中断，；



## 2、<span style="color:brown">模式选择：</span>

对照`datasheet`，根据`TMOD`寄存器结构：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Timer05.png" alt="image-20250915153320746" style="zoom:67%;" />

选择**定时器`Timer0`**，设置工作模式为**模式1**。



## 3、<span style="color:brown">时钟源：</span>

**3.1、结构图与配置：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Timer08.png" alt="image-20250915163110335" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Timer14.png" alt="image-20250916121354178" style="zoom: 67%;" />

| 模式         | C/T=0 (定时器)                                               | C/T=1 (计数器)                                               |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **计数来源** | 内部时钟                                                     | 外部引脚脉冲（`T0/T1`）                                      |
| **用途**     | <span style="color:red">计时、延时、周期任务</span>          | <span style="color:green">事件计数（转速、次数、外部信号）</span> |
| **是否独立** | 与外部输入无关                                               | 必须有**外部脉冲**才能计数                                   |
| **典型场景** | <span style="color:red">1ms 定时中断、LED 闪烁、采样定时</span> | <span style="color:green">电机转速检测、红外计数、测速仪</span> |

**3.2、分频模式选择：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Timer09.png" alt="image-20250915165414427" style="zoom: 67%;" />

假设**芯片时钟是`12 MHz`**进行**12分频**就是`1 MHz`（<span style="color:red">`1MHz=1000kHz，1kHz=1000Hz`，`1 s`计数`100`万次</span>），<u>每隔<span style="color:red">**1 us**</span>就要**记1次数**</u>。

`Timer0`的速率，在STC-ISP编程器中设置：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Timer10.png" alt="image-20250915165115906" style="zoom: 67%;" />



## 4、<span style="color:brown">开关控制：</span>

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Timer11.png" alt="image-20250915171154208" style="zoom:50%;" />

`GATE、INT0、TR0`一起作为**定时器开关的控制寄存器**：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Timer13.png" alt="image-20250916121656488" style="zoom:80%;" />

| <span style="color:red">GATE</span> | INT0 | <span style="color:red">TR0<</span> | 定时器状态 |
| ----------------------------------- | ---- | ----------------------------------- | ---------- |
| 0                                   | /    | 1                                   | 使能       |
| /                                   | 1    | 1                                   | 使能       |



## 5、<span style="color:brown">预装载值：</span>

**5.1、时基单元：**

> 该图片为13 bit Timer

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Timer12.png" alt="image-20250915171720205" style="zoom: 67%;" />

计数器里有**两个时基单元**：**TL0（低8位）**和 **TH0（高8位）**总共**16位**，所以叫**16位定时/计数器**。

`TL0`的**8位溢出向`TH0`进位**，<u>`TH0`计数溢出</u>就**置位TCON中**，即：<span style="color:blue">溢出标志位`TF0`</span>。

**5.2、数值计算：**

**16位定时/计数器**<u>最多可以计数 **`2^16`次**</u>，也就是**定时器增加到`65536`时，会触发一次溢出。**

**`STC89C52RC/RD+`单片机时钟频率**是`11.0592 MHz`时，在**12T模式**：

- 定时器频率：`11.0592 MHz /12 = 921600 Hz`；
- `1 s`计数**`921600`次**：`10 ms`计数`9216`次；



## 6、<span style="color:brown">定时器应用：</span>

**6.1、LED间隔1s闪烁：**

```c
#include <reg52.h>
// 设置溢出时间10ms
#define TIME_OUT (65536 - 9216)
int count = 0;
sbit LED2 = P2 ^ 6;
/*中断函数*/
void time0() interrupt 1{
    count++;
	if(count >= 100) { // 间隔1s闪烁
		LED2 = ~LED2; 
        count = 0;
	}
	// 每触发一次, 重新装在预装载值
	TL0 = TIME_OUT;
	TH0 = TIME_OUT >> 8;
}
void main() {
	/*初始化Timer0*/
	// 设置Timer0工作模式为模式1（M1、M0分别为0、1）
	// 设置Timer0时钟源, TCON.2|C/T为0（系统时钟）, 并作为定时器
	// 设置GATE为0
	TMOD = 0x01; // 0000 0001B
	// 设置预装载值
	// 10ms触发一次
	// 56320 -> 1101 1100 0000 0000
	TL0 = TIME_OUT; // 0000 0000B
	TH0 = TIME_OUT >> 8; // 1101 1100B
    // TCON.3 / GATE = 0, TR0 = 1, 按照与门逻辑, 定时器开始运行
	TR0  = 1;
	/*初始化Timer0中断*/
	// TF0由硬件设置, ET0置为1, 允许Timer0中断
	ET0 = 1;
	// 打开使能总开关
	EA  = 1;
	while(1){}
}
```

**6.2、KEY控制LED：**

> 软件空转延时消抖，参照《Button -> 机械按键》

**<u>Timer消抖原理</u>**：

1. 判断按键是否按下；
2. 若检测到有按键按下，则开启定时器，开启定时中断：
   - 定时时间为`10 ms`左右；
   - 使得按键按下`10ms`后进入定时中断（进入中断时，按键抖动时间已过）；
3. 在定时器中断中，再次判断按键是否按下；
4. 关闭定时器，等待按键松开；

```c
#include <reg52.h>
#define TIME_OUT (65536 - 9216)
sbit LED2 = P2 ^ 6;
sbit KEY2 = P3 ^ 6;
void time0() interrupt 1{
	TL0 = TIME_OUT;
	TH0 = TIME_OUT >> 8;
	TR0  = 0;
	if(KEY2 == 0) {
		LED2 = ~LED2; 
    	while(KEY2 == 0); // 检测KEY2电平变化, 返回main函数
	}
}
void main() {
	TMOD = 0x01;
	TL0 = TIME_OUT;
	TH0 = TIME_OUT >> 8;
    TR0  = 0;
	ET0 = 1;
	EA  = 1;
	while(1){
		if(KEY2 == 0) {
			TR0  = 1;
		}
        // 其它主循环任务可以放这里
	} 
}
```

**<u>代码解析</u>**：

1、程序启动 → main 初始化：

```c
TMOD = 0x01;         // Timer0 配置为模式1（16位定时器）
TL0 = TIME_OUT;      // 低 8 位初值
TH0 = TIME_OUT >> 8; // 高 8 位初值
ET0 = 1;             // 允许 Timer0 中断
EA  = 1;             // 全局中断开
TR0 = 0;             // Timer0 先关闭
```

2、进入主循环

```c
while(1){
    if(KEY2 == 0) {
        TR0 = 1;     // 检测到按键按下，启动定时器
    }
}
```

这里是一个死循环，程序一直卡在 `while(1)` 里：

- `KEY2`没有按下 → `TR0`保持`0`，定时器不运行；
- `KEY2`按下 → `TR0 = 1`，**定时器开始计数**；

3、定时器开始计数

- 一旦 `TR0=1`，`Timer0` 会从 `TIME_OUT`（`56320`）开始往上加；
- 当计到 `65536`，发生**溢出**，<span style="color:red">硬件自动置位 `TF0=1`</span>，触发中断；

4、进入中断函数

当溢出发生时，CPU 执行流程会：

- **自动跳转到 `time0()` ISR**（因为 ET0 和 EA 都打开了）；

- 执行你的代码：

  ```
  TL0 = TIME_OUT;
  TH0 = TIME_OUT >> 8;
  TR0 = 0;              // 关闭定时器（一次性使用）
  if(KEY2 == 0) {
      LED2 = ~LED2;     // 翻转 LED
      while(KEY2 == 0); // 等待KEY2电平变化
  }
  ```

  - 重新装载初值（为下次准备，但因为你又 `TR0=0`，其实不会继续跑）。
  - 定时器被关闭，只有下次按下时才会重新开启。
  - 如果按键仍然按下，就翻转 LED，并卡在 `while(KEY2==0)` 等待松开。

5、中断返回 → 主循环继续

- 一旦**`KEY2`变为`HIGH_LEVEL`**，`ISR`执行完毕，`CPU`**回到 `main()` 的 while(1)` 循环**继续执行；
- 再次按下按键，再次触发**TR0=1 → 溢出 → 中断**；
