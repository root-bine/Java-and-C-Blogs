## 1、<span style="color:brown">设置GPIO：</span>

**1.1、GPIO功能：**

根据<u>`STM32`芯片手册和原理图</u>，查看到`PC2`引脚：

| 1、外部连接按键`KEY2` | 2、引脚功能包含`GPIO_EXTI2` |
| :-------------------: | :-------------------------: |

**1.2、GPIO配置：**

❌**HAL_Delay延时**消抖：`KEY2`未按下是`HIGH_LEVEL`，按下是`LOW_LEVEL`，因此：`GPIO Mode`为**下降沿-触发外部中断**。

✅**双边沿触发**消抖：设置`GPIO Mode`为**上升沿 / 下降沿-触发外部中断** 。

**1.3、开启EXTI：**

在<u>完成GPIO的功能与配置</u>后，根据<span style="color:red">配置的`GPIO_EXTIx (x=0,1,...,15)`</span>在**`NVIC`开启`EXTI`**：

- `System Core -> GPIO`：选择`NVIX`，找到`EXTIx line interrupt (x=0,1,...,15)`，勾选Enabled；
- `System Core -> NVIX`：找到`EXTIx line interrupt (x=0,1,...,15)`，勾选`Enabled`；



## 2、<span style="color:brown">中断代码：</span>

**2.1、gpio.c：**

````c
void MX_GPIO_Init(void) {
  HAL_NVIC_SetPriority(EXTI2_IRQn, 0, 0); // 中断优先级
  HAL_NVIC_EnableIRQ(EXTI2_IRQn); // 使能中断
}
````

**2.2、stm32f1xx_it.c：**

````c
void EXTI2_IRQHandler(void) { // 中断服务函数
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2); 
}
````

**2.3、stm32f1xx_hal_gpio.c：**

```C
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin) { // GPIO中断配置
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u) 
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
}
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { // 中断GPIO回调 (可重定义)
  UNUSED(GPIO_Pin);
}
```



## 3、<span style="color:brown">功能实现：</span>

**3.1、情况说明：**

在`main`函数的`while`执行<u>`KEY2`点亮`LED1`操作</u>，如果**加入一个`HAL_Delay(20000)`操作**，则`LED`功能异常。

同时，在中断操作中，<span style="color:red">不建议使用延时函数</span>，因为**延时函数也依赖于中断** ：

- `HAL_Delay`函数，依赖中断：`Time base: System tick timer`；

针对机械按键的消抖处理，方案如下：1、`HAL_Delay`延时；2、利用`STM32`外部中断的**双边沿触发**机制；3、`Timer`中断

**3.2、工程代码：**

<u>延时函数</u>：❌

`EXTI2`采用**下降沿-触发外部中断**，则需要<u>修改`Time base: System tick timer`优先级</u>，否则**会卡死**：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/STM32_EXTI_03.png" alt="image-20251117180117467" style="zoom:67%;" />

````c
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
    if(GPIO_Pin == KEY2_Pin) {
        HAL_Delay(10);
	    if(HAL_GPIO_ReadPin(KEY2_GPIO_Port, KEY2_Pin) == 0) {
            HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
			while(HAL_GPIO_ReadPin(KEY2_GPIO_Port, KEY2_Pin) == 0);
        }
    }
}
````

<u>双边沿触发</u>：✅

````c
#define TIME_OUT 50
uint32_t falling_time = 0;
uint32_t risiing_time = 0;
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
	if(GPIO_Pin == KEY2_Pin) {
		if(HAL_GPIO_ReadPin(KEY2_GPIO_Port, KEY2_Pin) == 0) {
			falling_time = HAL_GetTick();
		} else if(HAL_GPIO_ReadPin(KEY2_GPIO_Port, KEY2_Pin) == 1) {
			risiing_time = HAL_GetTick();
			if(risiing_time - falling_time > TIME_OUT) {
				HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
			}
			falling_time = risiing_time = 0;
		}
	}
}
````

