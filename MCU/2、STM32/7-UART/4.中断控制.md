## 1、<span style="color:brown">功能函数：</span>

**1.1、函数说明：**

````c
HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef * huart, const uint8_t * pData, uint16_t Size) 

HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef * huart, uint8_t * pData, uint16_t Size)
````

**1.2、中断函数：**

> stm32f1xx_hal_uart.h，可在HAL库文档查询

|            Function             | 通过中断处理函数调用 |
| :-----------------------------: | :------------------: |
| `HAL_UART_TxHalfCpltCallback()` |       发送过半       |
|   `HAL_UART_TxCpltCallback()`   |       发送完毕       |
| `HAL_UART_RxHalfCpltCallback()` |       接收过半       |
|   `HAL_UART_RxCpltCallback()`   |       接收完毕       |
|   `HAL_UART_ErrorCallback()`    |  传输过程中出现错误  |



## 2、<span style="color:brown">功能实现：</span>

**2.1、USART中断配置：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/STM32_UART06.png" alt="image-20251127152959900" style="zoom:67%;" />

**2.2、工程代码：**

```C
"main.c -> 全局变量":
uint8_t rxbuf[10];
uint8_t ackbuf[] = "ack pack";
"main.c -> main()":
HAL_UART_Receive_IT(&huart1, rxbuf, sizeof(rxbuf)); // 初始化串口
"main.c -> main() After":
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){        
      if(huart == &huart1) {  //判断中断是否来自于串口1
          HAL_UART_Transmit_IT(&huart1, ackbuf, sizeof(ackbuf));  //通过中断的方式发送应答数据出去
          HAL_UART_Receive_IT(&huart1, rxbuf, sizeof(rxbuf));   //开始接收下一轮数据
      }
}
```

**MCU**每接收到一次`uint8_t rxbuf[10]`的数据，就会向**上位机**发送一次`ack pack`。

