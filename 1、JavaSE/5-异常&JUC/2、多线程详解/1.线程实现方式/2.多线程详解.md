## 1、<span style="color:brown">线程切换：</span>

**1.1、线程上下文：**

线程在执行过程中会有自己的运行条件和状态。

**1.2、什么是线程上下文切换?**

​		当发生<u>主动让出 CPU（调用了 `sleep()`, `wait()` 等）、时间片用完、调用了阻塞类型的系统中断（请求 IO，线程被阻塞）</u>这三类情况，就会<span style="color:green">**保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场，并加载下一个将要占用 CPU 的线程上下文**</span>！！！



## 2、<span style="color:brown">线程死锁：</span>

**2.1、什么是线程死锁？**

多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

**2.2、产生死锁的条件：**

- <u>互斥条件</u>：该资源任意一个时刻只由一个线程占用。
- <u>请求与保持条件</u>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
- <u>不剥夺条件</u>：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
- <u>循环等待条件</u>：若干线程之间形成一种头尾相接的循环等待资源关系

因此，<span style="color:red">如何预防死锁就需要**破环后三个条件**即可</span>！！！

**2.3、死锁案例分析：**

<u>死锁情况：</u>

```java
public class DeadLockDemo {
    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 1").start();

        new Thread(() -> {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + "get resource2");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource1");
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + "get resource1");
                }
            }
        }, "线程 2").start();
    }
}
```

```scss
Thread[线程 1,5,main]get resource1
Thread[线程 2,5,main]get resource2
Thread[线程 1,5,main]waiting get resource2
Thread[线程 2,5,main]waiting get resource1
```

​		线程 A 通过 `synchronized (resource1)` 获得 `resource1` 的监视器锁，然后通过`Thread.sleep(1000);`让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。

---

<u>解决死锁：</u>

> 修改线程2

```java
new Thread(() -> {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 2").start();
```

```scss
Thread[线程 1,5,main]get resource1
Thread[线程 1,5,main]waiting get resource2
Thread[线程 1,5,main]get resource2
Thread[线程 2,5,main]get resource1
Thread[线程 2,5,main]waiting get resource2
Thread[线程 2,5,main]get resource2
```

​		线程 1 首先获得到 resource1 的监视器锁，这时候线程 2 获取不到。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。



## 3、<span style="color:brown">图例分析：</span>

<u>随机性打印结果</u>：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/%E9%9A%8F%E6%9C%BA%E6%80%A7%E6%89%93%E5%8D%B0.png" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/%E9%9A%8F%E6%9C%BA%E6%80%A7%E6%89%93%E5%8D%B01.png" alt="多线程原理2" style="zoom:67%;" />

<u>多线程内存图解</u>：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.png" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%901.png" alt="内存分析2" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%902.png" alt="内存分析3" style="zoom:67%;" />