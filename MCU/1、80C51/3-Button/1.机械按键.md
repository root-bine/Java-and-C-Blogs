## 1、<span style="color:brown">机械按键：</span>

**1.1、设计原理：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Button01.png" alt="image-20250911144008294" style="zoom:50%;" />

上述原理图中，针对**`SW5`按键**处理：

- 松开按键，`IO = HIGH_LEVEL`，`SW5 = HIGH_LEVEL`；
- 按下按键，`IO = LOW_LEVEL`，`SW5 = LOW_LEVEL`；

**1.2、电平：**

以**`TTL`电路**为例：

- **TTL**电源电压是`3.3 V`，高电平是`2.4 V--3.3 V`，低电平`0 V--0.8 V`；
- 按照惯例，使用`1`来表示**高电平**，使用`0`表示**低电平**；



## 2、<span style="color:brown">按键值读取：</span>

**2.1、原理图：**

查看**按键**与**芯片的IO**的原理图：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Button02.png" alt="image-20250911145045995" style="zoom:50%;" />

`KEY1`、`KEY2`、`KEY3`三个`Button`，分别连接芯片的**`P3 IO`端口**，即：`P3.7`、`P3.6`、`P3.5`。

**2.2、按键控制LED亮灭：**

```c
#include <reg52.h>
/*按下KEY1->LED1亮, 松开KEY1->LED1熄灭*/
sbit LED1 = P2 ^ 7;
sbit KEY1 = P3 ^ 7;

void main() {
	if(KEY1 == 0) {
		LED1 = 0;
	} else {
		LED1 = 1;
	}
}
```

**2.2、按键点亮LED：**

```c
#include <reg52.h>
sbit led1= P2^7;         
sbit key1 = P3^7;
void main() {
    while(1) {
        //当按键按下时灯切换
        if(key1 == 0) {
            led1= ~led1;
        }
    }                
}
```

`Button`**按下**与**抬起**时，LED会变化**两次状态**，这是因为**`Button`在闭合和断开**时，**机械触点**会存在**抖动现象**。



## 3、<span style="color:brown">机械按键去抖：</span>

适用于PC与PC，计算机与外设之间的远距离通信，先传输低位再传输高位

**按下**/**松开**`Button`时，<u>接触的金属片</u>会因为**<u>弹性、震动等原因</u>，出现多个快速的电气跳变**，这种跳变叫做**抖动**。

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/Button03.png" alt="image-20250911153538817" style="zoom:50%;" />

**3.2、原理实现：**

当`Button`按下时，设置`delay = 5~10 ms`，目的是：**等待按键信号稳定下来**，再去<u>检查`KEY`的**电平高低**</u>。

同时为了防止**按键被重复触发**，在检测完**KEY电平**后，需要设置**delay**。

```c
// Function: 按下, LED亮起, 1s后熄灭
// 删除`LED1 = 1;`, 按下KEY, LED常亮, 再按下KEY, LED熄灭
#include <reg52.h>
sbit LED1 = P2^7;         
sbit KEY1 = P3^7;
void delay_ms(unsigned int xms);
void main() {
    LED1 = 1;
	if(KEY1 == 0) { // 检测Button是否按下
		delay_ms(10); // 延时等待Button信号稳定
        if(KEY1 == 0) { // 检测KEY是否LOW_LEVEL
        	LED1= ~LED1;
            delay_ms(1000); // 防止Button多次触发
        }
    }                
}
```

**3.3、void main()：**

单片机编程中，**main函数**使用`return_value_type = void`，原因如下：

1. **程序不会结束**：单片机程序一般为<span style="color:red">无限循环main函数</span>；
2. **返回值无意义**：<span style="color:brown">没有操作系统</span>；
3. **硬件层级设计**：单片机一般是<span style="color:brown">裸机编程</span>，进入**main函数不需要退出**；

同时采用的工作模式是： “**初始化 → 无限循环 main() ↔ 外设中断打断执行**” ！

**3.4、往复LED流水灯：**

```c
#include <reg52.h>
sbit LED1 = P2 ^ 7;
sbit LED2 = P2 ^ 6;
sbit LED3 = P2 ^ 5;
sbit KEY1 = P3 ^ 7;

void delay_ms(unsigned int ms);
void open_led(unsigned int num){
    P2 = 0xFF & ~(1 << num);
}
void main() {
    bit running = 0;  // 状态变量
    while(1) {
        if(KEY1 == 0) {          // 检测按键
            delay_ms(10);        // 消抖
            if(KEY1 == 0) {
                running = !running;   // 按一下切换运行/停止
                while(KEY1 == 0);     // 等待button状态改变(需要长按1-2s)
            }
        }
        if(running) {
            open_led(7); delay_ms(500);
            open_led(6); delay_ms(500);
            open_led(5); delay_ms(1000);
            open_led(6); delay_ms(500);
            open_led(7); delay_ms(500);
        } else {
            P2 = 0xFF;   // 全灭
        }
    }
}
```
