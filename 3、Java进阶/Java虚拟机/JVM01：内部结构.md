## 1、<span style="color:brown">什么是JVM？</span>

**1.1、本质：**

Java虚拟机，就是<u>*Java二进制字节码的运行环境*</u>。

**1.2、优点：**

- 保证Java跨平台特性；
- 自动管理内存，提供垃圾回收机制；
- 数组下标越界的检查；
- 多态；

**1.3、比较：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/JVM-JRE-JDK.png" alt="image-20221114165935547" style="zoom:67%;" />

**1.4、JVM内部组成：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/JVM-Structure.png" alt="image-20221114171449060" style="zoom:67%;" />



## 2、<span style="color:brown">程序计数器：</span>

**2.1、程序计数器存储内容：**

`Program Counter Register`是<u>当前线程所执行的字节码的行号指示器</u>。

字节码解释器工作时，就是**改变计数器中的数值**来<u>*选取下一条需要执行的字节码指令*</u>。

因此：<span style="color:red">程序计数器存储的是下一条JVM指令的执行地址</span>！！！

**2.2、程序计数器的特点：**

JVM的多线程实现：

```scss
通过'线程轮流切换', 并'分配处理器执行时间'来实现
```

因此：在任何一个确定的时刻，一个处理器都会执行一条线程中的指令。

- **<span style="color:green">线程私有</span>**

  ```scss
  为了'线程切换后能恢复正确的执行位置', 每条线程都需要一个'独立的程序计数器'
  
  这样可以保证每条线程之间计数器互不影响, 独立存储
  ```

- **<span style="color:green">不会存在内存溢出</span>**



## 3、<span style="color:brown">虚拟机栈、本地方法栈：</span>

<!--线程私有，生命周期与线程相同-->

<!--栈内存中栈帧是自动弹出, 因此不需要进行垃圾回收-->

<!--每个线程在创建的时候都会创建一个虚拟机栈, 而物理内存是固定的, 栈内存划分的越大, 可分配的线程数就越少-->

**3.1、功能：**

> 每一个方法在执行的同时都会创建一个栈帧（Stack Frame），用于存储方法相关的信息

|      |         Native Method Stack          |                Java Virtual Machine Stacks                 |
| :--: | :----------------------------------: | :--------------------------------------------------------: |
| 作用 |       Native方法执行的内存模型       | **<span style="color:blue">Java方法执行的内存模型</span>** |
| 区别 | 为虚拟机执行*Java方法 (字节码)* 服务 |              为虚拟机使用到的*Native方法*服务              |

**3.2、栈帧：**

每一个方法从调用到执行完成，对应*一个栈帧在虚拟机栈中入栈到出栈的过程*。

存储的信息包括：

```scss
局部变量表、操作数栈、动态链接、方法出口......
```

**3.3、局部变量表：**

该表存放的**方法内的局部变量**，关于线程安全分析：

1. 方法内局部变量没有逃离方法的作用范围，线程安全；
2. 局部变量引用了对象，且逃离了方法作用范围，需要考虑线程安全；

---

存放的局部变量类别：

- 编译期可知的各种基本数据类型：

  ```scss
  1. 64位(8比特)长度的long、double类型的数据会占用2个'局部变量空间(Slot)';
  2. 其余数据类型只占用1个;
  ```

- 对象引用：

  ```scss
  referencd类型, 不等同于对象本身, 可能是: 
  	1. 指向对象起始地址的引用地址;
  	2. 其他与此对象相关的位置;
  ```

- returnAddress类型：

  ```scss
  指向一条字节码指令的地址
  ```

**3.4、异常状况：**

根据JVM规范，在**虚拟机栈**与**本地方法栈**会有两种异常状况：

1. StackOverflowError异常

   ```scss
   当线程请求的栈深度 > 虚拟机允许的深度
   ```

2. OutOfMemoryError异常

   ```scss
   当'虚拟机栈'进行动态扩展时, 无法申请足够的内存
   ```



## 4、<span style="color:brown">Java堆：</span>也称为“GC堆”

**4.1、作用：**

存放对象实例，类别有：

- 使用new关键词创建的实例对象；
- 数组；

**4.2、特点：**

- JVM管理内存中最大的一块；
- 被所有线程共享；
- 虚拟机启动时创建；
- 有垃圾回收机制；

**4.3、堆内存划分：**

现在的收集器基本采用：分代收集算法，所以Java堆可以划分为：新生代、老年代。

之后还可以更进一步划分许多区域，这样做的目的：<u>*更好的回收内存，或者更快的分配内存*</u>！！！

---

Java堆内存可以处于<u>物理上不连续的内存空间</u>，只需逻辑上连续即可。在实现时，可以实现成**固定大小/可扩展**。

**4.4、异常状况：**

当<u>*堆中没有内存完成实例分配*</u>，且也<u>*无法完成扩展*</u>时，抛出OutOfMemoryError异常！！！



## 5、<span style="color:brown">方法区：</span>

**5.1、作用：**

用于存储已被JVM加载的**类信息、常量、静态变量、即时编译器编译后的代码**等数据。

**5.2、特点：**

1. 被所有线程共享；
2. 有垃圾回收机制；

**5.3、方法区内存功能：**

除了和`Java Heap`一样<u>不需要连续的内存</u>和<u>可以**选择固定大小**或者**可扩展**</u>外，还可以<u>*选择不实现垃圾回收*</u>。

而进行回收的目的主要是<u><span style="color:orange">对常量池的回收</span>和<span style="color:orange">对类型的卸载</span></u>，尽管在后者回收上效果不佳，但这是必须的回收！！！

**5.4、运行时常量池：**

Class文件中，除了有<u>类版本、字段、方法、接口</u>等信息，还包含了**常量池，用于存放<u>*<span style="color:green">编译期生成的各种字面值和符号</span>*</u>**。

常量池相当于一张表，JVM根据这张表找到类名、方法名、参数类型、字面值等。

---

当类被加载时，Class文件中的内容就会进入方法区的运行时常量池存放！！！

**5.5、异常状况：**

当**方法区/运行时常量池**无法满足内存分配需求，抛出OutOfMemoryError异常。

**5.6、补充：**

> 在IDEA中，可以查询已编译好的字节码文件信息

在out目录下，找到需要查询程序的Class文件，在控制台找到`Terminal按钮`，之后进入到out目录下对应程序的包下.

然后输入命令：`javap -v xxx.class`



## 6、<span style="color:brown">StringTable：</span>串池



## 7、<span style="color:brown">直接内存：</span>