## 1、<span style="color:brown">数组概述：</span>

**1.1、定义：**

- 是一种数据结构，是一个容器，可以存储多个数据；
- 在`Java`中，数组的大小是在创建数组时确定的，并且在数组的整个生命周期中保持不变；

**1.2、初始化方式：**

1. 动态初始化：

   ```java
   int[] arr = new int[10];
   ---------------------------------------------------------------------------------------------------------
   int[] arr;
   arr = new int[10];
   ```

2. 静态初始化：

   ```java
   int[] arr = new int[]{10, 20, 30};
   ---------------------------------------------------------------------------------------------------------
   int[] arr = {10, 20, 30};
   ```



## 2、<span style="color:brown">一维数组：</span>

**2.1、数组名：**

直接打印“数组名”，得出的结果是：**`内存地址哈希值`**，即：**`地址值`**

```java
int [] a=new int[10];
System.out.println(a); //[I@340f438e
```

**2.2、数组访问：**

采用**`索引值`**进行访问，索引值从`0`开始，到`arr.length-1`为止；

```java
int [] a={10,20,30,40};
for(int i=0;i<a.length;i++){
	System.out.println(a[i]); // 10 20 30 40
}
```

**2.3、数组的输出方式：**

```java
int [] a={10,20,30,40};
//for循环
for(int k=0; k<a.length; k++){
	System.out.print(a[k]);
}
//foreach
for (int n:a) {
	System.out.print(n);
}
```



## 3、<span style="color:brown">二维数组：</span>

**3.1、定义与初始化：**

二维数组（`arr[][]`）相当于<u>定义`n`个一维数组（`arr[]`），每个一维数组中存放一个数组</u>。其中各部分含义为：

- `arr.length`：表示二维数组得行数
- `arr[].length`：表示每一行有多少列
- `arr[i][j]`：表示具体的某一个数据

初始化方式有：

1. 动态初始化：`int[][] arr = new int[3][4]`；
2. 静态初始化：`int[][] arr = new int[][]{{...},{...},...}`或者`int[][] arr = {{...},{...},...}`；

**3.2、数组遍历与赋值：**

```java
public class Main{
    public static void main(String[] args) {
        int[][] arr = new int[3][4];
        /*遍历1*/
        for (int[] ints : arr) { 
            for (int anInt : ints) {
                System.out.print(anInt+" ");
            }
            System.out.println();
        }
        /*赋值*/
        for (int i = 0; i < arr.length; i++) {//行数
            for (int j = 0; j < arr[i].length; j++) {//列数
                arr[i][j] = i + j;
            }
            System.out.println();
        }
        /*遍历2*/
        System.out.println("赋值后数组: ");
        for (int i = 0; i < arr.length; i++) {//行数
            for (int j = 0; j < arr[i].length; j++) {//列数
                System.out.print(arr[i][j]+" ");
            }
            System.out.println();
        }
        
      	/*遍历3*/
        int rows = arr.length;
        int cols = arr[0].length;
    	for (int i = 0; i < rows; i++) {
        	for (int j = 0; j < cols; j++) {
            	System.out.print(matrix[i][j] + " ");
        	}
        	System.out.println();
    	}
    }
}
```

```scss
0 0 0 0 
0 0 0 0 
0 0 0 0 
赋值后数组: 
0 1 2 3 
1 2 3 4 
2 3 4 5 
```



## 4、<span style="color:brown">经典算法：</span>🎑🎑🎑

**4.1、数组中位数？**

给定一个无序数组，输出数组的中位数。若数组长度为奇数，直接输出中间值；若长度为偶数，则输出中间两数的均值。

```java
public double getMedian(int[] nums) {
    Arrays.sort(nums);
    int len = nums.length;
    if(len % 2 == 0) {
        int n1 = nums[len/2 - 1];
        int n2 = nums[len/2];
        return (double)(n1+n2)/2.0;
    }else {
        return (double)nums[len/2];
    }
}
```

**4.2、旋转矩阵？**

**`顺时针90度`**：

```java
public int[][] rotateMatrixUp(int[][] matrix, int rotations) {
    int rows = matrix.length;
    int cols = matrix[0].length;
    // 对矩阵进行旋转操作
    for (int k = 0; k < rotations; k++) {
        // 创建一个临时矩阵用于存储旋转后的结果
        int[][] temp = new int[cols][rows];
        // 顺时针旋转90度
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                temp[j][rows - 1 - i] = matrix[i][j];
            }
        }
        // 将旋转后的结果复制回原矩阵
        matrix = temp;
        // 更新行列数
        int tempRows = rows;
        rows = cols;
        cols = tempRows;
         
        return matrix;
    }
}
```

**`逆时针90度`**：

```java
public int[][] rotateMatrixDown(int[][] matrix, int rotations) {
    int rows = matrix.length;
    int cols = matrix[0].length;
    // 对矩阵进行旋转操作
    for (int k = 0; k < rotations; k++) {
        // 创建一个临时矩阵用于存储旋转后的结果
        int[][] temp = new int[cols][rows];
        // 逆时针旋转90度
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                temp[cols - 1 - j][i] = matrix[i][j];
            }
        }
        // 将旋转后的结果复制回原矩阵
        matrix = temp;
        // 更新行列数
        int tempRows = rows;
        rows = cols;
        cols = tempRows;
        
        return matrix;
    }
}
```

**4.3、反转矩阵？**

<u>由于矩阵时对称的</u>，因此对矩阵进行横向、纵向反转时，只需要<u>对`cols`、`rows`进行减半</u>操作，即：`cols/2`、`rows/2`！！！

**`水平翻转`**：

```java
public int[][] fanzhuan(int[][] matrix) {
    int rows = matrix.length;
    int cols = matrix[0].length;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols / 2; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[i][cols - j - 1];
            matrix[i][cols - j - 1] = temp;
        }
    }
    return matrix;
}
```

**`垂直翻转`**：

```java
public int[][] fanzhuan(int[][] matrix) {
    int rows = matrix.length;
    int cols = matrix[0].length;
    for (int i = 0; i < rows / 2; i++) {
        for (int j = 0; j < cols; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[rows - i - 1][j];
            matrix[rows - i - 1][j] = temp;
        }
    }
    return matrix;
}
```

