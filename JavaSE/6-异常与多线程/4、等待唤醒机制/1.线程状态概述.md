# 线程的状态

## 1、<span style="color:brown">概述：</span>

**1.1、分析：**

```apl
在线程启动之后，线程不是立刻就处于执行状态，也不会一直处于执行状态
```

**1.2、Thread的内部类：**

```java
java.lang.Thread.State
```

## 2、<span style="color:brown">线程状态概述：</span>

**2.1、六种状态：**

- NEW：`至今尚未启动的线程`；
- RUNNABLE：`在Java虚拟机中正在执行的线程`；
- BLOCKED：`受到阻塞并等待某个监视器锁的线程`；
- WAITING：`无限期等待另一个线程执行某一特定操作的线程`；
- TIMED_WAITING：`等待另一个线程来执行取决于指定等待时间的线程`；
- TERMINATIED：`已退出的线程`；

**2.2、图解：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" style="zoom:150%;" />

**2.3、阻塞与休眠：**

阻塞：

```apl
具有CPU的执行资格，需要等待CPU空闲
```

休眠：

```apl
放弃了CPU的执行资格，即使CPU空闲，也不执行
```

## 3、<span style="color:brown">等待唤醒案例：</span>WAITING状态

**3.1、案例分析：**

![](https://raw.githubusercontent.com/root-bine/image/main/Typora-image/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1.png)

**3.2、案例实现：**

```java
public class Waiting {
    public static void main(String[] args) {
        //创建一个锁对象
        Object obj = new Object();
        //创建消费者线程
        new Thread(){
            @Override
            public void run() {
                System.out.println("顾客说出需要的食物种类和数量");
                //进入无线等待状态
                synchronized(obj){
                    try {
                        obj.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("获取食物，完毕！！");
                }
            }
        }.start();
        //创建生产者线程
        new Thread(){
            @Override
            public void run() {
                //等待五秒，制作食物
                synchronized (obj){
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //对消费者线程进行唤醒
                synchronized (obj){
                    obj.notify();
                    System.out.println("食物做好了");
                }
            }
        }.start();
    }
}
```

```apl
顾客说出需要的食物种类和数量
食物做好了
获取食物，完毕！！
```

## 4、<span style="color:brown">等待唤醒案例：</span>TIMED_WAITING状态

**4.1、进入TIMED_WAITING状态方式：**

1. 使用sleep（long  m）方法，在毫秒值结束后，`线程睡眠进入RUNNABLE状态 或者BLOCKED状态`；
2. 使用wait（long  m）方法，在毫秒值结束后，`还没有被notify唤醒，就会自动醒来`，并且进入RUNNABLE或者BLOCKED状态；

**4.2、唤醒TIMED_WAITING状态方式：**

1. 使用notify（）；
2. 使用notifyALL（）；

**4.3、范例：**

```java
public class Waiting {
    public static void main(String[] args) {
        //创建一个锁对象
        Object obj = new Object();
        //创建消费者线程
        new Thread(){
            @Override
            public void run() {
                //进入无线等待状态
                synchronized(obj){
                    System.out.println("顾客1说出需要的食物种类和数量");
                    try {
                        obj.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("顾客1获取食物，完毕！！");
                }
            }
        }.start();
        new Thread(){
            @Override
            public void run() {
                //进入无线等待状态
                synchronized(obj){
                    System.out.println("顾客2说出需要的食物种类和数量");
                    try {
                        obj.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("顾客2获取食物，完毕！！");
                }
            }
        }.start();
        //创建生产者线程
        new Thread(){
            @Override
            public void run() {
                //等待五秒
                synchronized (obj){
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //对消费者线程进行唤醒
                synchronized (obj){
                    //obj.notify();//一次只能唤醒一个等待线程
                    obj.notifyAll();
                    System.out.println("食物做好了");
                }
            }
        }.start();
    }
}
```
