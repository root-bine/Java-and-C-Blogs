## 1、<span style="color:brown">Java Memory Model介绍：</span>

> <u>*Java 是最早尝试提供内存模型的编程语言*</u>

**1.1、Java 内存区域和 JMM 有何区别？**

| 类别     | 解释                                                         |
| -------- | ------------------------------------------------------------ |
| 内存区域 | 和Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据 |
| JMM      | 和 Java 的并发编程相关，抽象了线程和主内存之间的关系，<br>规定了从 Java 源代码到 CPU 可执行指令的转化过程要遵守哪些和并发相关的原则和规范，<br>目的是为了简化多线程编程，增强程序可移植性的 |

**1.2、为什么需要 JMM？**

- Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异

  ```apl
  # 一般来说, 编程语言可以直接复用操作系统层面的内存模型
  不过, 不同的操作系统内存模型不同
  如果直接复用操作系统层面的内存模型, 就可能会导致同样一套代码换了一个操作系统就无法执行
  ```

- 简化多线程编程，增强程序可移植性的

  ```apl
  对于 Java 来说, 可以把 JMM 看作是 Java 定义的并发编程相关的一组规范: 
  		1. 抽象了线程和主内存之间的关系
  		2. 规定了'从 Java 源代码到 CPU 可执行指令的转化过程'要遵守哪些和并发相关的原则和规范
  ```

**1.3、为什么要遵守这些并发相关的原则和规范呢？**

因为并发编程下，像 **CPU 多级缓存**和**指令重排**这类设计可能会导致程序运行出现一些问题，如：指令重排序就可能会让多线程程序的执行出现问题。为此，JMM 抽象了 `happens-before` 原则来解决这个指令重排序问题



## 2、<span style="color:brown">Java 内存模型详解：</span>

**2.1、内存分类：**

> **JMM** 抽象了线程和主内存之间的关系

| 名称     | 解释                                                         |
| -------- | ------------------------------------------------------------ |
| 主内存   | 所有线程创建的实例对象都存放在主内存中，不管实例对象是**成员变量**还是**方法中的局部变量** |
| 本地内存 | 每个线程都有<u>一个私有的本地内存来存储共享变量的副本</u>，且**只能访问自己的本地内存**，无法访问其他线程的本地内存 |

**2.2、JMM的抽象示意图：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/JMM01.png" alt="QQ截图20221213170640" style="zoom:50%;" />

从上图来看，线程 1 与线程 2 之间如果要进行通信的话，必须要经历下面 2 个步骤：

1. 线程 1 把本地内存中修改过的共享变量副本的值同步到主内存中去；
2. 线程 2 到主存中读取对应的共享变量的值；

也就是说，<span style="color:red">**JMM 为共享变量提供了可见性的保障**</span>！！！

**2.3、JMM的同步操作：**（了解）

一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，J<u>ava 内存模型定义来以下**八种同步操作**</u>：

[#](#)<span style="color:green">**lock（锁定）**</span>：作用于主内存中的变量，将其标记为一个线程独享变量

[#](#)<span style="color:green">**unlock（解锁）**</span>： 作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定

[#](#)<span style="color:green">**read（读取）**</span>：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中

[#](#)<span style="color:orange">**load（载入）**</span>：把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中

[#](#)<span style="color:blue">**use（使用）**</span>：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令

[#](#)<span style="color:blue">**assign（赋值）**</span>：把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作

[#](#)<span style="color:blue">**store（存储）**</span>：作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中

[#](#)<span style="color:orange">**write（写入）**</span>：作用于主内存的变量，把 store 操作从工作内存中得到的变量的值放入主内存的变量中

**2.4、JMM的同步规范：**（了解）

除8 种同步操作之外，还规定了一些同步规则来保证这些同步操作的正确执行：

- 不允许<span style="color:brown"><u>*一个没有发生过任何 assign 操作的线程*</u></span>把数据从线程的工作内存同步回主内存中；

- <span style="color:brown">一个新的变量只能在主内存中生成</span>，不允许在工作内存中直接使用一个未被初始化（未load 或 assign）的变量；

- 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次。多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁；

- 如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值。在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值；

- 如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量；



## 3、<span style="color:brown">happens-before原则：</span>

**3.1、为什么需要 happens-before 原则？**

 happens-before 原则的诞生是<u>*为了程序员和编译器、处理器之间的平衡*</u>。

- 程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可；
- 编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化；

**3.2、 JSR-133 对 happens-before 原则的定义：**

<u>*如果一个操作 happens-before 另一个操作*</u>：

```apl
1. 第一个操作的执行结果将对第二个操作可见
2. 第一个操作的执行顺序排在第二个操作之前
```

<u>*两个操作之间存在 happens-before 关系*</u>：

```apl
1. Java 平台的具体实现不一定按照 happens-before 关系指定的执行顺序
2. 如果重排序之后的执行结果, 与按 happens-before 关系来执行的结果一致, 那么 JMM 也允许这样的重排序
```

综上，`happens-before` 原则表达的意义是<span style="color:red"><u>*前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里*</u></span>！！！

**3.3、happens-before的常见规则：**

> 补充： <u>volatile 变量的**写操作的结果**</u>对于<u>发生于其后的**任何操作**</u>都是可见的。

<span style="color:green">**程序顺序规则**</span> ：一个线程内，按照代码顺序，书写在前面的操作 happens-before 书写在后面的操作；

<span style="color:green">**解锁规则**</span> ：解锁 happens-before 加锁；

<span style="color:green">**volatile 变量规则**</span> ：对一个 volatile 变量的写操作 happens-before 后面对这个 volatile 变量的读操作；

<span style="color:green">**传递规则**</span> ：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；

<span style="color:green">**线程启动规则**</span> ：Thread 对象的 `start()`方法 happens-before 此线程的每一个动作；



## 4、<span style="color:brown">并发编程特性：</span>

### [#](#原子性)原子性

<u>*一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行*</u>。

在 Java 中，可以借助`synchronized` 、各种 `Lock` 以及各种原子类实现原子性：

- `synchronized` 和各种 `Lock` 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性；
- 各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 `volatile`或者`final`关键字）来保证原子操作；

### [#](#可见性)可见性

<u>*当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值*</u>。

在 Java 中，可以借助`synchronized` 、`volatile` 以及各种 `Lock` 实现可见性。

如果我们将变量声明为 `volatile` ，相当于告知 JVM：这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

### [#](#有序性)有序性

<u>*由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序*</u>。

**指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致** ，所以在多线程下，指令重排序可能会导致一些问题。

在 Java 中，`volatile` 关键字可以禁止指令进行重排序优化！！！
