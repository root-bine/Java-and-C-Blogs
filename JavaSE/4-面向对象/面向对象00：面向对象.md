# oop基础理解

- 面向对象与面向过程：

  1. 面向过程：强调步骤；

  2. 面向对象：强调对象；

- 类与对象：

  1. 类：一组相关属性和行为的集合；

  2. 对象：一类事物的具体表现；

  3. 定义类格式：

  ​	修饰词  class  类名{

  ​			属性；

  ​			行为；

  ​	} 

  4. 对象的定义：

     类名   对象名 = new  类名();

  5. 调用类中的变量和方法：

     对象名.变量；

     对象名.方法();

  
  注意：
  
  1. <font color="#0099ff">此处的行为即方法，但是不在强制一定要加上static修饰了；</font>
  
  2. <font color="#0099ff">由于缺少了static的修饰，不能够让方法随类一起加载，因此需要对象进行调用类中的方法与变量；</font>
  3. <font color="#0099ff">通常，一个类定义一个功能；</font>
  4. <span style='color:violet'>在面向对象中，通常是多个类集合在一起，只有一个主类，其他类是功能的实现。因此，此时在主类中需要导包【当类跟主类不在同一个包下时】：import   包名.类名；</span>
  
- 成员变量与局部变量的区别：

  1. 定义位置不一样：

     成员变量：<font color="#0099ff">位于类中，方法外</font>；

     局部变量：<font color="#0099ff">位于方法中或者方法的参数列表中</font>；

  2. 作用范围不一样：

     成员变量：<font color="#0099ff">整个类可以通用</font>；

     局部变量：<font color="#0099ff">仅在方法中有意义</font>；

  3. 默认值不一样：

     成员变量：<font color="#0099ff">默认值的规则跟数组等一致；</font>

     局部变量：<font color="#0099ff">没有默认值</font>

  4. 内存位置不一样：

     成员变量位于Heap内存里面，局部变量位于Stack内存里面；

  5. 生命周期不一样：

     <span Style='color:orange'>成员变量随着对象的创建而产生，随着对象的垃圾回收而释放；</span>

     <span style='color:orange'>局部变量进Stack诞生，出Stack释放；</span>

  注意：<span style='color:red;background:背景颜色;font-size:文字大小;font-family:字体;'>static 可以修饰方法和变量，当整个程序加载时，类变量和类方法随着类一起加载。</span>

- 两个对象指向同一个类中的方法和属性，这两个属性互不相干，各自执行自己的作用。

  - <span style ='color:orange'>***当同一个类中的两个对象产生了关联***</span>，如：

    ```java
    Phone one = new Pnone();
    Phone two = one;
    ```

    - 此时对象one的地址值和其中的内容会赋值给对象two。

  - <span style='color:orange'>***使用对象类型作为方法的参数***</span>：

    ```java
    public class Demo02 {
        public static void main(String[] args) {
            Phone one = new Phone();
            one.brand = "苹果";
            one.price = 830.59;
            one.color = "红色";
            getPhone(one);
        }
        public static void getPhone(Phone prame){
           System.out.println(prame.brand);
           System.out.println(prame.price);
           System.out.println(prame.color);
        }
    }
    ```

    ```java
    public class Phone {
        String brand;//null
        double price;//0.0
        String color;//null
    
        public void call(String who){
            System.out.println("给"+who+"打电话");
        }
        public void sendMessage(){
            System.out.println("群发消息");
        }
    }
    ```

    此处的对象phone将其中的地址值赋值给了prame。所以prame就具备了phone地址值中的内容。

  - <span style='color:orange'>***使用对象类型作为方法的返回值***</span>：

    ```java
    public class Demo02 {
        public static void main(String[] args) {
            Phone two = getPhone();//由于返回值是one，此时相当于将one的地址值赋值给two
            System.out.println(two.brand);
            System.out.println(two.color);
            System.out.println(two.price);
        }
        public static Phone getPhone(){//此处用Phone作为方法的返回值类型，返回是one
            Phone one = new Phone();
            one.brand="apple";
            one.price=5854.0;
            one.color="白色";
            return one;
        }
    }
    ```

    ```java
    public class Phone {
        String brand;//null
        double price;//0.0
        String color;//null
    
        public void call(String who){
            System.out.println("给"+who+"打电话");
        }
        public void sendMessage(){
            System.out.println("群发消息");
        }
    }
    ```

- **<u>垃圾收集器</u>**：

  ```apl
  # 在一个Java 程序中的执行是自动的, 不能强制执行
  1. 即使程序员能明确地判断出有一块内存已经无用了, 是应该回收的, 序员也不能强制垃圾收集器回收该内存块;
  2. 程序员唯一能做的就是'通过调用System.gc()方法':
         ---> 来"建议"垃圾收集器去进行垃圾回收处理，但其是否可以执行，什么时候执行却都是不可知的。
  ```
