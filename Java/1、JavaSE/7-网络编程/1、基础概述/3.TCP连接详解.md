## 1、<span style="color:brown">三次握手：</span>Three-way Handshake[建立连接]

**1.1、概述：**

```scss
建立一个TCP连接时, 需要客户端和服务器总共发送3个包

初始状态：
	客户端处于 Closed 状态;
	服务端处于 Listen 状态;
```

**1.2、作用：**

> ***实质：***<span style="color:red">连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息</span>！！！

1. 确认双方的**接收能力和发送能力是否正常**
2. **指定自己的初始化序列号**为后面的<u>可靠性传送</u>做准备

**1.3、三次握手过程中可以携带数据吗？**

​	<span style="color:red">第`3`次握手的时候，是可以携带数据的，第`1`次、第`2`次握手不可以携带数据</span>。

​	假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。攻击者根本就不理会服务器的接收、发送能力是否正常，只需要疯狂着重复发 SYN 报文，就可以<u>让服务器花费很多时间、内存空间来接收这些报文</u>。

​	对于第三次握手，此时客户端已经处于 `ESTABLISHED(已确认连接)` 状态。对于客户端来说，已经建立起连接，并且已经知道服务器的接收、发送能力是正常的。

**1.4、什么是半连接队列？**

1. 服务器**第一次收到客户端的 SYN报文** 之后，就会**处于 SYN_RCVD 状态**；
2. 但此时双方还**没有完全建立其连接**，服务器会*把此种状态下请求连接放在一个队列里*；

***补充：***<span style="color:Orange">**已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象！！！**</span>

**1.5、SYN攻击是什么？**

​	Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认。由于源地址不存在，因此Server需要不断重发直至超时。
​	这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪！！

***补充：***<span style="color:blue">**服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击**</span>



## 2、<span style="color:brown">四次挥手：</span>Four-way handshake[终止连接]

**2.1、概述：**

```scss
TCP 连接的拆除需要发送四个包   ----->  四次挥手

TCP的半关闭:     ------>   建立一个连接需要三次握手，而终止一个连接需要四次挥手
	TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力;

初始状态:
	刚开始双方都处于ESTABLISHED(已确认连接)状态
```

**2.2、挥手为什么需要四次？**

1. 当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。
   - 其中**ACK报文是用来应答的，SYN报文是用来同步的**。
2. 当关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文；
   - 告诉客户端，“你发的FIN报文我收到了”。
3. 只有等到我服务端所有的报文都发送完了，我才能发送FIN报文。

**2.3、TCP的双全工特性：**

- 在四次挥手中，由于TCP连接是全双工的，因此每个方向都必须单独进行关闭；
- 当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接；
- 收到一个FIN只意味着这一方向上没有数据流动，但仍能发送数据；



## 3、<span style="color:brown">三次握手和四次挥手的过程：</span>

**3.1、三次挥手：**

1. 第一次握手：客户端向服务器发送一个`SYN（同步）包`，其中包含一个随机生成的`初始序列号（ISN）`；
2. 第二次握手：服务器收到客户端的`SYN包`后，会发送一个`SYN+ACK（同步+确认）包`作为响应：
   - 该包中确认了客户端的`SYN`，并且也包含一个随机生成的`ISN`
3. 第三次握手：客户端收到服务器的`SYN+ACK包`后，会发送一个`ACK（确认）包`给服务器，确认收到了服务器的响应。同时，客户端也会将<u>服务器的`ISN`加1作为下一次通信的初始序列号</u>；

**3.2、四次挥手：**

1. 第一次分手：当客户端决定关闭连接时，发送一个`FIN（结束）包`给服务器；
2. 第二次分手：服务器收到客户端的`FIN包`后，会发送一个`ACK包`作为响应，确认收到了客户端的关闭请求；
3. 第三次分手：服务器发送一个`FIN包`给客户端，表示服务器也准备关闭连接；
4. 第四次分手：客户端收到服务器的`FIN包`后，发送一个`ACK包`作为响应，确认收到了服务器的关闭请求；



## 4、<span style="color:brown">HTTP和HTTPS：</span>🎑🎑🎑

**4.1、什么是HTTP和HTTPS？**

> HTTPS是HTTP的扩展，更为安全

`HTTP` 和 `HTTPS`，即：<span style="color:red">超文本传输协议</span>，是**一种用于在万维网上传输超文本请求和信息的协议**，是**万维网数据通信的基础**。

**4.2、主要区别有哪些？**

- `HTTP` <u>不安全，数据以明文形式传输</u>，而 `HTTPS` 使用 **`SSL / TLS加密数据`** ，通过 `Internet` 提供安全通信。
- `HTTP` 通过 **`端口80`** 运行，而 `HTTPS` 通过 **`端口443`** 运行；
- `HTTPS` 需要 `SSL/TLS证书` 进行身份验证，而 `HTTP` 则不需要；
- `HTTPS URL` 以 `https://` 开头，而  `HTTP URL ` 以 `http://` 开头；

**4.3、为什么 HTTPS 对网站很重要？**

1. `HTTPS` 对<span style="color:red"><u>用户浏览器和网站之间传输的数据进行加密</u></span>，从而**`提供数据的机密性和完整性`**；
2. <span style="color:green">对网站进行身份验证</span>，确保用户连接到正确的网站而不是冒名顶替者；

**4.4、SSL/TLS 在 HTTPS 中如何工作？**

> <u>`SSL`（安全套接字层）</u>、 <u>`TLS`（传输层安全）</u>是<span style="color:red">通过网络提供安全通信的加密协议</span>。

​	当用户的浏览器请求安全连接 （`https://`） 时，服务器会将其 SSL/TLS 证书发送到浏览器。然后，浏览器会验证证书，以确保其有效且受信任。验证后，浏览器和服务器将建立安全连接并交换加密数据。

**4.5、与 HTTP 相比，使用 HTTPS 对性能有何影响？**

​	<u>由于加密和解密过程，HTTPS 会增加计算开销</u>，与 HTTP 相比，这可能会略微增加延迟和处理时间。然而，随着硬件和软件优化的进步，对大多数网站的性能影响通常可以忽略不计！！！

