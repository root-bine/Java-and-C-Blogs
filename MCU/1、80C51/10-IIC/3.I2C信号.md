## 1、<span style="color:brown">Start & Stop：</span>

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/IIC12.png" alt="image-20251027175912832" style="zoom: 40%;" />

**1.1、起始信号：**

```c
void i2c_start(){
	scl = 1;
	sda = 1;
	Delay10ms();
	sda = 0;
	Delay10ms();
}
```

**1.2、结束信号：**

```c
void i2c_stop(){
	scl = 1;
	sda = 0;
	Delay10ms();
	sda = 1;
	Delay10ms();
}
```



## 2、<span style="color:brown">ACK & NACK：</span>

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/IIC13.png" alt="image-20251027180831813" style="zoom:40%;" />

**2.1、应答信号：**

```c
void i2c_ack(){
	scl = 0;
	sda = 0;
	Delay10ms();
	scl = 1;
	Delay10ms();
	scl = 0;
	Delay10ms();
}
```

**2.2、非应答信号：**

```c
void i2c_nack(){
	scl = 0;
	sda = 1;
	Delay10ms();
	scl = 1;
	Delay10ms();
	scl = 0;
	Delay10ms();
}
```

**2.3、等待应答/非应答信号：**

```c
unsigned char i2c_wait_ack(){
	unsigned char ack_level = 0;
	sda = 1; // 主机释放总线
	// 模拟SCL从0->1->0的过程
	scl = 0;
	Delay10ms();
	scl = 1;
	Delay10ms(); //延时使得数据稳定
	ack_level = sda; // 读取SDA电平, 0表示ACK, 1表示NACK
	scl = 0;
	Delay10ms();
	return ack_level;
}
```

使用`unsigned char`，而非`unsigned int`，是因为`ack_level`表示SDA的电平：`0 或 1`，数据大小为`8 bit`。



## 3、<span style="color:brown">Data Transfer：</span>

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/IIC14.png" alt="image-20251027183749187" style="zoom:50%;" />

延时影响**`I2C`的通信速率**，如：拉低延时`10 ms`，拉高延时`10 ms`，一个周期为`20 ms`，速率 = `1 / 20 ms` =`50 Hz`。

**3.1、数据发送：**

```c
void i2c_write_byte(unsigned char wdata) {
        unsigned char i;
        for(i = 0; i < 8; i++) {
                scl = 0; //开始发送前，设置scl为0
                delay10ms();
                //判断最高位是1/0，是1设置sda输出高电平，是0设置sda输出低电平。
                if(wdata& 0x80) {
                    sda=1;
                } else {
                    sda=0;
                }
                scl=1; 
                delay10ms();
                wdata=wdata<<1;//左移一位，for循环8次，直到数据发送完
        }
}
```

**3.2、数据读取：**

```c
unsigned char i2c_read_byte() {
        int i,value;
        sda=1;    //释放总线
        for(i=0;i<8;i++) {
                scl=0; 
                delay10ms();
                scl=1; 
                delay10ms();    //等待数据稳定再读
                value=value<<1; //移出位置空位准备接收
                if(sda == 1) {
                    //读取数据放到最低位
                    //sda=1的时候就把最后一位置1，
                    //sda=0的时候则不用置，因为默认为0
                    value = value|0x01;
                }
        }
        return value;
}
```

