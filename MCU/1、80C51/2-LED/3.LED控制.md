## 1、<span style="color:brown">bit、sbit、sfr：</span>

**1.1、bit：**

在`C51`单片机，`bit`是一种数据类型，大小是`1 bit`，数值为**`0`/ `1`**：

```c
bit i = 0; // 在内存中划一块空间给i, 并存储数值0
bit i = 1; // 在内存中划一块空间给i, 并存储数值1
```

**1.2、sfr：**

`Special Function Register`，简称**sfr**，用于定义一个**字节寄存器**（8 位整体操作）：

```c
sfr P4 = 0xE8; // 定义 P4 口寄存器, 物理地址 0xE8
```

**1.3、sbit：**

`sbit`是为**已经分配内存空间的变量**重新<u>取一个别名</u>，一般用来<u>定义特殊功能寄存器</u>的**位变量**，例如

```Java
sfr P1 = 0x90;
sbit Flag = P1^1;
Flag = 0; // 输出低电平
Flag = 1; // 输出低电平
```



## 2、<span style="color:brown">时钟周期、机器周期、指令周期：</span>

**2.1、时钟周期：**

> <u>`MCU`主时钟频率</u>由**外部晶振**提供
>
> **主时钟的频率**的单位通常是`MHz`或者`GHz` 

**主时钟频率**为`12 MHz`的晶振，**时钟周期**为`1/12 us`，是计算机中**最基本的、最小的时间单位**。

**2.2、机器周期：**

> 一般情况下，**一个机器周期**由**若干个时钟周期**组成

<u>取指令、存储器读、存储器写</u>等每一个基本操作，**<u>完成所需要的时间</u>称为**机器周期。

**2.3、指令周期：**

> `Control Unit`，简称`CU`，即：控制器
>
> `Arithmetic Logic Unit`，简称`ALU`，即：算术逻辑单元
>
> `Instruction register`，简称`IR`，即：指令寄存器
>
> `Memory`，即：存储器

`CPU`从`Memory`中**取出并执行一条指令所需的时间**，称为**指令周期**。

| 阶段                                   | 主要内容                                                     |
| :------------------------------------- | :----------------------------------------------------------- |
| **取指令 **<br/>`Instruction Fetch`    | 1. **PC Register**给出指令地址<br>2. 从**Memory**取出指令<br>3. 指令送入 **IR**<br>4. **PC Register**更新到下一条指令地址 |
| **指令译码**<br/> `Instruction Decode` | 1. `Control Unit`读取 **IR 内的指令**<br/>2. 判断**指令类型**（算术/逻辑/传输/跳转等）<br/>3. 解析**需要的操作数**、**目标寄存器 / 内存地址**<br/>4. 生成**控制信号** |
| **执行**<br/>`Execute`                 | 1. `ALU` 根据**控制信号**执行操作（算术/逻辑）<br/>2. 完成数据传送（寄存器 ↔ 内存 ↔ I/O）<br/>3. 若为分支/跳转，**PC Register**更新为<u>新地址</u><br/>4. 结果写回`Register`或`Memory` |



## 2、<span style="color:brown">软件空转延时：</span>

> 软件空转延时仅作为了解，核心是**定时器**和**RTOS** 

**2.1、STC-ISP工具生成：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/LED08.png" alt="image-20250909182104404" style="zoom: 40%;" />

`#include "intrins.h"`，是`Keil`给`80C51`单片机编程时，提供的**“内联汇编 / 固有函数（intrinsic functions）”**声明文件。

**2.2、12 Mhz晶振延时：**

> `j = 124`，是根据**CPU 主频**和编译器生成的**机器码指令周期数**算出来的

```c
//带参延时函数
void delay_ms(unsigned int xms) {  //@12MHz
    unsigned int i, j;
    for(i=xms;i>0;i--) {
        for(j=124;j>0;j--) {}
    }
}
```



## 3、<span style="color:brown">灯效控制：</span>

**3.1、单LED闪烁：**

操作整个**`GPIO`端口**：

```c
#include "reg52.h"
void delay_ms(unsigned int xms);
void main(){
	while(1) {
        P2 = 0x7F; // 0111 1111, LED1亮
		delay_ms(500);
		P2 = 0xFF; // 1111 1111, LED1熄灭
		delay_ms(500);
    }
}
```

`sbit`定义**位变量**：

```c
#include <reg52.h>
void delay_ms(unsigned int xms);
sbit LED1 = P2^7; // LED 1
int main() {
	while(1) {
        LED1 = 0; // LED1亮
		delay_ms(500);
		LED1 = 1; // LED1熄灭
		delay_ms(500);
    }
}
```

**3.3、LED流水灯：**

根据**GPIO**和**LED原理图**，可以针对<u>LED1、LED2、LED3</u>所在的`Register-Bit`进行操作

```c
sbit LED1 = P2^7; // LED 1
sbit LED2 = P2^6; // LED 2
sbit LED3 = P2^5; // LED 3
while(1) {
	LED1 = 0;
	LED2 = 1;
	LED3 = 1;
	delay_ms(500);
	LED1 = 1;
	LED2 = 0;
	LED3 = 1;
	delay_ms(500);
	LED1 = 1;
	LED2 = 1;
	LED3 = 0;
	delay_ms(500);
}
```

根据`datasheet`中，**`P2`端口**的复位值是：`1111 1111B`，`LED1 = 0;LED2 = 1;LED3 = 1;`可<span style="color:red">优化</span>为：

```c
P2 = 0xDF; //1101 1111, 操作P2.5, LED3
P2 = 0xBF; //1011 1111, 操作P2.6, LED2
P2 = 0x7F; //0111 1111, 操作P2.7, LED1
```

该步骤也可以简化为一个函数：

```c
// 0xFF = 1111 1111
// 1    = 0000 0001
void open_led(unsigned int num){
    P2 = 0xFF & ~(1 << num);
}
```

`~(1 << num)`表示左移`num`位，并取反，在与0xFF按位与，效果等同上一个方案！

