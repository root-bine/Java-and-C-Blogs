## 1、<span style="color:brown">ADC数据：</span>

**1.1、数据输出：**

✅可以采用`UART &USART`进行**ADC数据打印**：

````c
#include "stdio.h"
int fputc(int ch, FILE *f) {
    HAL_UART_Transmit(&huart1 , (uint8_t *)&ch, 1, 0xFFFF);
    return ch;
}
````

**1.2、ADC校准：**

````c
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef * hadc) 
````

芯片生产过程中，会出现**各类参数的变化**导致**ADC的测量结果产生误差**，因此：

- 使用**ADC校准**提高**测量精度**；
- 规定在<u>使用`ADC`采样的时候</u>都需要进行**ADC校准**；



## 2、<span style="color:brown">轮询采样：</span>

**2.1、查询函数：**

````c
HAL_StatusTypeDef HAL_ADC_PollForConversion (ADC_HandleTypeDef * hadc, uint32_t  Timeout) 
````

`ADC`一直在**后台自动转换**，每完成一次转换，就产生一个 **EOC 标志**。

`HAL_ADC_PollForConversion()`只能看到 **下一次 EOC**，因此<span style="color:purple">`HAL_Delay()`延时不宜过长</span>。

**2.2、分辨率：**

`STM32`的**3个ADC**都是**12位**，因此：

| `2`的`12`次方，是`4096` | 供电电压`3.3 v` |
| :---------------------: | :-------------: |

可得出分辨率为：`3.3f / 4096`。

**2.3、工程代码：**

> 补充UART串口转Printf打印

````c
"main.c -> main() Before"
HAL_ADCEx_Calibration_Start(&hadc1);
HAL_ADC_Start(&hadc1);     			 //启动ADC转换，设置为连续采样后，只需开启一次
"main.c -> main() -> while(1)"
HAL_ADC_PollForConversion(&hadc1,50);
uint16_t ADC_Value = HAL_ADC_GetValue(&hadc1);   //获取AD值
printf("ADC1 Reading : %d \r\n",ADC_Value);
printf("PA1 True Voltage value : %.4f \r\n",ADC_Value*3.3f/4096);
HAL_Delay(500);
HAL_ADC_Stop(&hadc1);
````



## 2、<span style="color:brown">中断采样：</span>

**2.1、ADC中断：**

✅开启`ADC`的**NVIC中断配置** ：

![image-20251130165322307](https://raw.githubusercontent.com/root-bine/image/main/Typora-image/STM32_ADC10.png)

**单通道**时，推荐<span style="color:red">直接用ADC中断采样</span>。

**2.2、工程代码：**

```C
"main.c -> main() Before"
HAL_ADCEx_Calibration_Start(&hadc1); 
"main.c -> main() -> while(1)"
HAL_ADC_Start_IT(&hadc1); //每秒转换一次，是否可以反正while外，只初始化一次
HAL_Delay(1000);
"main.c -> main() After"
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {    //ADC转换完成回调
    HAL_ADC_Stop_IT(&hadc1);    　　　　                     //关闭ADC
    uint16_t ADC_Value=HAL_ADC_GetValue(&hadc1);　　		  //获取ADC转换的值
    printf("ADC1 Reading : %d \r\n",ADC_Value);
    printf("%.4f V\r\n",(ADC_Value*3.3/4096));　　　        //串口打印电压信息
}
```

## 3、<span style="color:brown">DMA采样：</span>

**3.1、应用场景：**

`DMA`采样，一般<span style="color:red">用于**高采样率+多通道情况**，防止对CPU的占用过高</span>。

**3.2、参数配置：**

`Parameter Settings`：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/STM32_ADC08.png" alt="image-20251130165124252" style="zoom: 50%;" />

`DMA Settings`：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/STM32_ADC09.png" alt="image-20251130171320388" style="zoom:67%;" />

DMA模式配置成Circular模式，会导致**DMA连续不断采样但数据传输未完成**，触发不了DMA传输完成中断，导致程序逻辑卡住。

**3.3、工程代码：**

````c
"main.c -> main() Before"
uint32_t ADC1_Value_DMA[2];
HAL_ADCEx_Calibration_Start(&hadc1); 
HAL_ADC_Start_DMA(&hadc1, ADC1_Value_DMA, 2);
"main.c -> main() -> while(1)"
float Channel_0 = (float)(ADC1_Value_DMA[0]&0xFFF)*3.3/4096;
float Channel_1 = (float)(ADC1_Value_DMA[1]&0xFFF)*3.3/4096;
printf("ADC1 Channel_6 Count: %d,   voltage: %f \r\n",ADC1_Value_DMA[0],Channel_0);
printf("ADC1 Channel_7 Count: %d,   voltage:  %f \r\n",ADC1_Value_DMA[1], Channel_1);
````

