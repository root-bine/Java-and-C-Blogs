## 1、<span style="color:brown">发送流程：</span>

**1.1、发送结构图**：

> 模式1

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/UART17.png" alt="image-20251007164101478" style="zoom: 67%;" />

**1.2、软件操作分析：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/UART20.png" alt="image-20251010125305788" style="zoom: 67%;" />



## 2、<span style="color:brown">工作模式：</span>

**2.1、模式分类：**

**模式0**主要用于<span style="color:green">并行口扩展</span>。

<span style="color:red">**模式1**是最常用的工作模式</span>。

**模式2**和**模式3**，**多出的第9位**可作**校验位**或**地址识别位**。

|    编号    | 名称 / 类型    | 数据位数                           | 波特率                                   |
| :--------: | :------------- | ---------------------------------- | ---------------------------------------- |
| **模式 0** | 同步移位寄存器 | **8 位数据**                       | **固定波特率**：`fosc/12`                |
| **模式 1** | 异步 UART      | 10 位（1起始 + **8数据** + 1停止） | **可变波特率**（由`Timer1`产生）         |
| **模式 2** | 异步 UART      | 11 位（1起始 + **9数据** + 1停止） | **固定波特率**（`fosc/64` 或 `fosc/32`） |
| **模式 3** | 异步 UART      | 11 位（1起始 + **9数据** + 1停止） | **可变波特率**（由`Timer1`产生）         |

**2.2、配置SCON：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/UART18.png" alt="image-20251007163302012" style="zoom:80%;" />

```c
SM0 = 0;
SM1 = 1;
REN = 1;
或
SCON = 0x50;                // 0101 0000 串口工作模式1
```

**寄存器结构上**：`SM0=0`、`SM1=1`设置**模式1**，`REN=1`打开接收，使 `UART` 处于<span style="color:red">完整可用状态</span>。

**通信机制上**：`UART` 是<span style="color:red">全双工结构</span>，<u>即使只发送</u>，也应**启用接收以维持状态机稳定**。



## 3、<span style="color:brown">波特率配置：</span>

**3.1、参数配置：**

根据《**常用波特率与定时器/计数器1各参数关系**》，<u>**模式1** + 波特率为`9600`</u>：

| PCON.7 / SMOD = 0 | TMOD.6 / C/T = 0 | Mode2：8 bit auto load | 预装载值 = 0xFD |
| ----------------- | ---------------- | ---------------------- | --------------- |

**3.2、Timer1配置：**

```c
TMOD &= 0x0F;  //清空TMOD中定时器1相关
TMOD |= 0X20;  //设置定时器1工作模式2 8位自动重载，这里为什么使用|=而不使用=呢，为了避免清除定时器0配置
TH1 = 0xFD;    //设定初值
TL1 = 0XFD;    //设定装载值 
TR1 = 1;       //打开计数器
```

多定时器情况下， `TCOM = 0x20`会导致`Timer0`设置被修改，因此做如下修改：

- `TMOD &= 0x0F`：清理`Timer1`中可能残留的数据，并保留`Timer0`的配置；
- `TMOD |= 0X20`：设置`Timer1`新数值时，确保`Timer0`数值保留；

**3.3、PCON配置：**

```c
PCON |= 0X00;  //设置B7为0
```

`PCON` 的 `SMOD` 位控制波特率倍速（置1为两倍波特率），<span style="color:red">不加倍则不需要设置</span>。



## 4、<span style="color:brown">校验位：</span>

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/UART19.png" alt="image-20251007165205262" style="zoom:67%;" />

在**模式2、模式3**作为**校验位**。**模式0**和**模式1**的<u>数据部分</u>是`8 bit`的，<span style="color:red">**无需校验位**</span>。



## 5、<span style="color:brown">UART发送数据：</span>

**5.1、单字节数据：**

```c
#include <reg52.h>
void UartInit() {           // 9600bps、11.0592MHz
        SCON = 0x50;        // 0101 0000 串口工作模式1
        TMOD &= 0x0F;       // 清空TMOD中定时器1相关
        TMOD |= 0X20;       // 设置Timer1 -> 工作模式2: 8位自动重载
        TH1 = 0xFD;         // 设定定时初值
        TL1 = 0XFD;
        TR1 = 1;            // 启动定时器1
        PCON |= 0X00;       // 可省略
}
void main() {
        UartInit(); //调用串口初始化函数
        SBUF = 0x30;
        TI=0;
        while(1) {}        
}
```

**5.2、多字节数据：**

```c
#include <reg52.h>
char str[] = "java and c\n";
void UartInit() {
        SCON = 0x50;
        TMOD &= 0x0F;
        TMOD |= 0X20; 
        TH1 = 0xFD;
        TL1 = 0XFD;
        TR1 = 1;
    	PCON |= 0X00;
}
void send_string(char *str) {
        unsigned char i=0;
        while(str[i]!='\0') { //判断是否到字符串尾
        	SBUF = str[i];
            while(TI==0);    //等待发送完成, 发送完成硬件会置1
            TI=0;            //下次发送前, 软件置0
            i++;             //下次发送
        }        
}
void main() {
        UartInit();//调用串口初始化函数
        send_string(str);
        while(1) {}        
}
```

**5.3、printf发送数据：**

在MCU中使用printf函数，需要引入头文件：#include <stdio.h>，<span style="color:red">重写printf调用的putchar函数，重定向到串口输出</span>：

```c
SCON = 0x50;
char putchar(char dat) {
        SBUF = dat;
        while(TI == 0);
        TI = 0; 
        return dat;
}
```

之后就可以在main函数中使用：`printf("hello\r\n");` 

**5.4、复位运行：**

烧录程序进入MCU，**手动按一次复位键**，PC串口工具才能**接收一次数据**。原因如下：

- **`ISP` (下载器)** <u>在烧录时，会占用**`UART`引脚**</u>：`P3.0 RXD`、`P3.1 TXD`，<span style="color:red">让MCU进入下载模式</span>无法退出；

**5.5、中断位TI：**

> `0x30 = 1 byte`、`hello world!! > 1 byte` 

UART的工作模式：`0、1、2、3`，<u>一字符帧大小是`8 byte` / `10 byte` / `11 byte`</u>，因此**多字节数据发送**：

1. 检测**一字符帧**是否发送完毕：<span style="color:red">**硬件**已将`TI`置`1`</span>；
2. **软件复位`TI`**，即：`TI = 0`；
