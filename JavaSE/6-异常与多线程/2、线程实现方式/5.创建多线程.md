# 创建多线程程序方法：

## 1、<span style="color:brown">第一种方式：</span>创建Thread类的子类

**1.1、概述：**

```apl
java.lang.Thread类，用于描述多线程的类
```

**1.2、步骤：**

1. 创建一个Thread类的子类类；
2. 在Thread类的子类中，`重写run方法，并在其中设置线程任务`；
3. 在主方法中，创建Thread类的子类对象；
4. `调用Thread类中的start方法，开启新线程，执行run方法`；

**1.3、注意：**

1. start方法使线程开始执行，让JVM使用该线程的run方法；
2. 结果是，两个线程同时运行：`当前线程（main线程）和另一个的线程（创建的新线程，执行run法）`；
3. <span style="color:Orange">**多次启动一个线程是不合法的。特别是，一个线程结束执行后，不能再次重新启动**</span>；

**1.4、范例：**

输出结果排列顺序可能会不一致，原因：线程随机性【抢占式调度】

```java
public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("run"+i);
        }
    }
}
```

```java
public class DemoThread01 {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
        for (int i = 0; i < 10; i++) {
            System.out.println("main"+i);
        }
    }
}
```

## 2、<span style="color:brown">第二种方式：</span>声明实现Runnable接口

**2.1、概述：**

````apl
java.lang.Runnable接口，在具体创建线程时，'只需要重写run()方法即可'。
````

**2.2、步骤：**

1. 定义Runnable接口的实现类，`重写其中的run方法，并在方法中编写线程任务`；
2. 创建Runnable接口的实现类对象，以`此对象作为Thread的target来创建线程对象`；
3. `使用线程对象，调用start方法`，开启线程，让JVM执行该线程的run方法；

**2.3、范例：**

```java
public class RunnableImpl implements Runnable{
    @Override
    public void run() {
        //获取新线程的对象名称
        for (int i = 0; i < 20; i++) {
            System.out.println(Thread.currentThread().getName()+"-->"+i);
        }
    }
}
```

```java
public class Demo03Runnable {
    public static void main(String[] args) {
        RunnableImpl  runnable = new RunnableImpl();
        Thread thread = new Thread(runnable);
        thread.start();
        //获取主线程的名称
        for (int i = 0; i < 20; i++) {
            System.out.println(Thread.currentThread().getName()+"-->"+i);
        }
    }
}
```

```apl
main-->0
Thread-0-->0
Thread-0-->1
Thread-0-->2
Thread-0-->3
Thread-0-->4
main-->1
main-->2
main-->3
main-->4
Thread-0-->5
main-->5
```

## 3、<span style="color:brown">第三种方式：</span>使用匿名内部类{减少Runnable代码冗余}

**3.1、概述：**

```apl
使用线程的匿名内部类方式，目的在于：方便每个线程执行不同的线程任务
```

**3.2、步骤：**

`使用匿名内部类的方式实现Runnable接口/Thread类，重写Runnable接口/Thread类中的run 方法`

**3.3、范例：**

```java
public class Demo04InnerClassThread {
    public static void main(String[] args) {
        //线程的父类Thread
        new Thread(){
            @Override
            public void run() {
                for (int i = 0; i < 3; i++) {
                    System.out.println(Thread.currentThread().getName()+"-->"+i);
                }
            }
        }.start();

        //线程的接口Runnable
        Runnable r = new Runnable(){
            @Override
            public void run() {
                for (int i = 0; i < 3; i++) {
                    System.out.println(Thread.currentThread().getName()+"-->"+i);
                }
            }
        };
        new Thread(r){}.start();
        //关于线程接口Runnable的编写简化
        new Thread(new Runnable(){
            @Override
            public void run() {
                for (int i = 0; i < 3; i++) {
                    System.out.println(Thread.currentThread().getName()+"-->"+i);
                }
            }
        }){}.start();
    }
}
```

```apl
Thread-0-->0
Thread-0-->1
Thread-0-->2
Thread-1-->0
Thread-1-->1
Thread-1-->2
Thread-2-->0
Thread-2-->1
Thread-2-->2
```

