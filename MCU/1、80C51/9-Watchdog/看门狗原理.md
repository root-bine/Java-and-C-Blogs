## 1、<span style="color:brown">原理分析：</span>

**1.1、应用与机制：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/WDT01.png" alt="image-20251012170043599" style="zoom:67%;" />

<span style="color:brown"><u>触发机制</u></span>：

1. 启动`Watchdog`**计数器**；
2. 计数器计数；
3. 指定时间内：
   - 不喂狗 -> 溢出，发出复位信号；
   - 重新喂狗 -> 程序正常执行；

**1.2、寄存器说明：**

`STC89C51RC/RD+`系列单片机，`Watchdog`寄存器表：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/WDT02.png" alt="image-20251012170747370" style="zoom:67%;" />

**1.3、溢出时间计算：**

`PS2、PS1、PS0`，表示`Watchdog`的**溢出时间**，参考公式：
$$
TimeOut = (12 * Pre-scale * 32768) / Oscillator frequency
$$
`datasheet`也直接给出不同频率单片机的参数表格：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/WDT03.png" alt="image-20251012171325786" style="zoom:67%;" />



## 2、<span style="color:brown">功能实现：</span>

```c
#include <reg52.h>
#include <stdio.h>
sfr WDT_CONTR = 0xE1;
void delay_ms(unsigned int xms) {
    unsigned int i, j;
    for(i=xms;i>0;i--)
    {
        for(j=124;j>0;j--)
        {}
    }
}
    
void Init_Uart() {
	// PCON &= 0x7F;
	SCON  = 0x50;
	TMOD &= 0x0F;
	TMOD |= 0x20;
	TR1   = 1;
	TL1   = 0xFD;
	TH1   = 0xFD;
}
char putchar(char dat) {
	SBUF = dat;
	while(TI == 0);
	TI = 0;
	return dat;
}
void main() {
    Init_Uart();
	WDT_CONTR = 0x35;
	printf("hello\r\n");
	while(1) {
		delay_ms(3000);
	}
}
```

上述代码，选择`WDT Overflow Time = 2.2755 s`。

`while(1) {delay_ms(3000);}`执行延时：`3 s > 2.2755 s`，触发了`Watchdog Reset`：

- 烧录程序后，按一次**芯片复位键**；
- 在串口工具中，一直重复接收`hello`；

因此，针对`while`修改如下：

```c
delay_ms(2000);
WDT_CONTR = 0x35;
```

