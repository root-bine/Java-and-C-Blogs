## 1、<span style="color:brown">中断概述：</span>

**1.1、定义：**

中断（`Interrupt`）：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/External_Interrupt01.png" alt="image-20250912140227628" style="zoom: 67%;" />

**1.2、问题引入：**

```c
#include <reg52.h>
void delay_ms(unsigned int xms);
sfr  P4   = 0xE8;
sbit KEY4 = P4 ^ 3;
sbit LED1 = P2 ^ 7;
void main() {
    if(KEY4 == 0) {
        LED1 = ~LED1;
        delay_ms(1000);
    }
    delay_ms(20000); // 延时20s
}
```

上述代码用于实现**触控按键操控LED**，在加入 `delay_ms(20000)`后，<u>LED不能正常响应</u>。

因为<u>整个`IC`都在处理`delay_ms(20000)`</u>，就无法处理**按键事件（`Key Events`）**。



## 2、<span style="color:brown">中断类型：</span>

**2.1、中断分类：**

`51`单片机的中断类型，包括：

|         Name          |                    Description                     |
| :-------------------: | :------------------------------------------------: |
|       外部中断        |              由**外部引脚**触发的中断              |
| 定时器（`Timer`）中断 |               由**定时器**触发的中断               |
|  串口（`UART`）中断   | 通讯过程中，**`Send / Receive`数据完毕触发**的中断 |

**2.2、中断请求源：**

> 参照对应芯片的datasheet

`STC89C51RC/RD+`系列单片机提供了 **8 个中断请求源**，分别是：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/External_Interrupt02.png" alt="image-20250912141728883" style="zoom:50%;" />

外部中断（`External interrupt`）是：`INT0、INT1、INT2、INT3`，对应芯片引脚：`P3.2、P3.3、P4.3、P4.2`。



## 3、<span style="color:brown">外部中断：</span>

**3.1、触发方式：**

`INT0、INT1、INT2、INT3`的触发方式：1、**低电平触发**；2、**下降沿触发**。

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/External_Interrupt03.png" alt="image-20250912144014543" style="zoom:50%;" />

请求<u>`External interrupt`的**标志位**</u>，是位于以下**寄存器**：

| `IE0` / `TCON.1` | `IE1` / `TCON.3` | `IE2` / `XICON.2` | `IE3` / `XICON.5` |
| ---------------- | ---------------- | ----------------- | ----------------- |

当**外部中断服务程序被响应**后，**`External interrupt`标志位**都会**自动被清`0`**。（<span style="color:red">不需要手动设置，由`CPU`处理即可</span>）

**3.2、中断寄存器：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/External_Interrupt04.png" alt="image-20250912161712737" style="zoom:50%;" />

详细寄存器信息参照datasheet，简要信息：

|  Name   | Description                                                  |
| :-----: | :----------------------------------------------------------- |
|  `IE`   | 中断允许**寄存器**（<span style="color:green">可位寻址</span>） |
| `XICON` | 辅助中断**控制寄存器**（<span style="color:green">可位寻址</span>） |
| `TCON`  | 定时器/计数器中断**控制寄存器**（<span style="color:green">可位寻址</span>） |
| `SCON`  | 串行口**控制寄存器**（<span style="color:green">可位寻址</span>） |
|  `IP`   | 中断优先级**控制寄存器**低（<span style="color:green">可位寻址</span>） |
|  `IPH`  | 中断优先级**控制寄存器**高（<span style="color:red">不可位寻址</span>） |



## 4、<span style="color:brown">中断操作：</span>

**4.1、中断系统结构：**

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/External_Interrupt05.png" alt="image-20250912152114235" style="zoom: 50%;" />

配置`External interrupt`，需要<span style="color:brown">结合**“中断系统结构图”**和**”中断寄存器表及信息“**，配置**对应的寄存器**</span>。

**4.2、中断服务程序（回调函数）：**

在`main.c`中进行`Interrupt`操作时，<u>**中断功能**与**中断初始化**之间**无绑定**</u>，因此要使用**中断服务程序**进行关联：

<img src="https://raw.githubusercontent.com/root-bine/image/main/Typora-image/External_Interrupt06.png" alt="image-20250912173626003" style="zoom:50%;" />

**4.3、中断配置：**

> `STC89C51RC/RD+`系列单片机，**P4.3引脚**属于复用引脚，兼顾`QC`和`INT2`，而`KEY1、KEY2、KEY3`均连接普通`GPIO` 

引入头文件和延时函数：

```c
#include <reg52.h>
void delay_ms(unsigned int xms);
```

查看`reg52.h`，没有定义`P4 IO、XICON_Register、XICON_Bit`。

因为`Keil C51`选择**89C52芯片**时，厂商只能选择**AT**，实验`IC`厂商为**STC**，因此要手动配置**`P4 IO`端口**：

```c
sfr P4    = 0xE8;
```

结合**原理图**、**中断系统结构**、**中断寄存器表**，配置`INT2`、`XICON`（<span style="color:red">reg52.h并没有定义</span>）：

```c
sbit INT2 = P4 ^ 3;
sfr XICON = 0xc0;                
sbit PX3  = XICON ^ 7;
sbit EX3  = XICON ^ 6;
sbit IE3  = XICON ^ 5;
sbit IT3  = XICON ^ 4;
sbit PX2  = XICON ^ 3;
sbit EX2  = XICON ^ 2;
sbit IE2  = XICON ^ 1;
sbit IT2  = XICON ^ 0;
```

初始化**LED**和**KEY**，编写**中断函数**（<span style="color:red">不允许中断里面添加延时函数</span>，会<u>**影响其他中断的产生**</u>）：

```c
sbit key1 = P4 ^ 3;
sbit led1 = P2 ^ 7;
void exit2() interrupt 6 {
    // LED1 = 1; 程序进入main函数无限循环, 致使LED1值一直为0
	// 当按键按下时灯切换
  	if(key1 == 0) {
    	led1= ~led1;
    	// delay_ms(1000);
  }
}
```

**初始化中断**，并设置`while(1) {delay_ms(20000);}` 任务：

```c
void main() {
    IT2 = 1; // 设置中断触发条件为下降沿
    EX2 = 1; // 运行中断2经过
    EA = 1;  // 使能中断(reg52.h已定义)
    while(1) {
         delay_ms(20000);
    }                
}
```

当`INT2`所在的**`GPIO`引脚**，<u>**电平变为0**</u> / **<u>处于下降沿</u>**，就会**触发中断函数**。
